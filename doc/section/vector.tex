\section{1-Dimensional Lists (Vectors)}
Lists are foundational to Tcl, so in addition to providing utilities for ND-lists, this package also provides utilities for working with 1D-lists, or vectors.
\subsection{Range Generator}
The command \cmdlink{range} simply generates a list of integer values. 
This can be used in conjunction with the Tcl \textit{foreach} loop to simplify writing ``for'' loops.
There are two ways of calling this command, as shown below.
\begin{syntax}
\command{range} \$n \\
range \$start \$stop <\$step>
\end{syntax}
\begin{args}
\$n & Number of indices, starting at 0 (e.g. 3 returns 0 1 2). \\
\$start & Starting value. \\
\$stop & Stop value. \\
\$step & Step size. Default 1 or -1, depending on direction of start to stop.
\end{args}
\begin{example}{Integer range generation}
\begin{lstlisting}
puts [range 3]
puts [range 0 2]
puts [range 10 3 -2]
\end{lstlisting}
\tcblower
\begin{lstlisting}
0 1 2
0 1 2
10 8 6 4
\end{lstlisting}
\end{example}
\begin{example}{Simpler for-loop}
\begin{lstlisting}
foreach i [range 3] {
    puts $i
}
\end{lstlisting}
\tcblower
\begin{lstlisting}
0
1
2
\end{lstlisting}
\end{example}
\clearpage
\subsection{Logical Indexing}
The command \cmdlink{find} returns the indices of non-zero elements of a boolean list, or indices of elements that satisfy a given criterion.
Can be used in conjunction with \cmdlink{nget} to perform logical indexing.
\begin{syntax}
\command{find} \$list <\$op \$scalar>
\end{syntax}
\begin{args}
\$list & List of values to compare. \\
\$op & Comparison operator. Default ``!=''. \\
\$scalar & Comparison value. Default 0.
\end{args}
\begin{example}{Filtering a list}
\begin{lstlisting}
set x {0.5 2.3 4.0 2.5 1.6 2.0 1.4 5.6}
puts [nget $x [find $x > 2]]
\end{lstlisting}
\tcblower
\begin{lstlisting}
2.3 4.0 2.5 5.6
\end{lstlisting}
\end{example}
\subsection{Linear Interpolation}
The command \cmdlink{linterp} performs linear 1D interpolation.
Converts input to ``\cmdlink{float}''.
\begin{syntax}
\command{linterp} \$x \$xList \$yList
\end{syntax}
\begin{args}
\$x & Value to query in \texttt{\$xList} \\
\$xList & List of x points, strictly increasing \\
\$yList & List of y points, same length as \texttt{\$xList}
\end{args}
\begin{example}{Linear interpolation}
\begin{lstlisting}
puts [linterp 2 {1 2 3} {4 5 6}]
puts [linterp 8.2 {0 10 20} {2 -4 5}]
\end{lstlisting}
\tcblower
\begin{lstlisting}
5.0
-2.92
\end{lstlisting}
\end{example}
\clearpage
\subsection{Vector Generation}
The command \cmdlink{linspace} can be used to generate a vector of specified length and equal spacing between two specified values. 
Converts input to ``\cmdlink{float}''
\begin{syntax}
\command{linspace} \$n \$start \$stop 
\end{syntax}
\begin{args}
\$n & Number of points \\
\$start & Starting value \\
\$stop & End value
\end{args}
\begin{example}{Linearly spaced vector generation}
\begin{lstlisting}
puts [linspace 5 0 1]
\end{lstlisting}
\tcblower
\begin{lstlisting}
0.0 0.25 0.5 0.75 1.0
\end{lstlisting}
\end{example}
The command \cmdlink{linsteps} generates intermediate values given an increment size and a sequence of targets.
Converts input to ``\cmdlink{float}''.
\begin{syntax}
\command{linsteps} \$step \$x1 \$x2 ...
\end{syntax}
\begin{args}
\$step & Maximum step size \\
\$x1 \$x2 ... & Targets to hit.
\end{args}
\begin{example}{Intermediate value vector generation}
\begin{lstlisting}
puts [linsteps 0.25 0 1 0]
\end{lstlisting}
\tcblower
\begin{lstlisting}
0.0 0.25 0.5 0.75 1.0 0.75 0.5 0.25 0.0
\end{lstlisting}
\end{example}

\clearpage
\subsection{Functional Mapping}
The command \cmdlink{lapply} simply applies a command over each element of a list, and returns the result.
Basic math operators can be mapped over a list with the command \cmdlink{lop}.
\begin{syntax}
\command{lapply} \$command \$list \$arg ...
\end{syntax}
\begin{syntax}
\command{lop} \$list \$op \$arg... 
\end{syntax}
\begin{args}
\$list & List to map over. \\
\$command & Command prefix to map with. \\
\$op & Math operator (see ::tcl::mathop documentation). \\
\$arg ... & Additional arguments to append to command after each list element. 
\end{args}

\begin{example}{Applying a math function to a list}
\begin{lstlisting}
# Add Tcl math functions to the current namespace path
namespace path [concat [namespace path] ::tcl::mathfunc]
puts [lapply abs {-5 1 2 -2}]
\end{lstlisting}
\tcblower
\begin{lstlisting}
5 1 2 2
\end{lstlisting}
\end{example}

\clearpage
\subsection{Mapping Over Two Lists}
The commands \cmdlink{lapply} and \cmdlink{lop} only map over one list.
The commands \cmdlink{lapply2} and \cmdlink{lop2} allow you to map, element-wise, over two lists.
List lengths must be equal. 
\begin{syntax}
\command{lapply2} \$command \$list1 \$list2 \$arg ...
\end{syntax}
\begin{syntax}
\command{lop2} \$list1 \$op \$list2 \$arg... 
\end{syntax}
\begin{args}
\$list1 \$list2 & Lists to map over, element-wise. \\
\$command & Command prefix to map with. \\
\$op & Math operator (see ::tcl::mathop documentation). \\
\$arg ... & Additional arguments to append to command after list elements. \\
\end{args}

\begin{example}{Mapping over two lists}
\begin{lstlisting}
lapply puts [lapply2 {format "%s %s"} {hello goodbye} {world moon}]
\end{lstlisting}
\tcblower
\begin{lstlisting}
hello world
goodbye moon
\end{lstlisting}
\end{example}

\begin{example}{Adding two lists together}
\begin{lstlisting}
puts [lop2 {1 2 3} + {2 3 2}]
\end{lstlisting}
\tcblower
\begin{lstlisting}
3 5 5
\end{lstlisting}
\end{example}

\clearpage
\subsection{List Math}
The Tcl command \textit{lmap} allows you to loop over an arbitrary number of lists in parallel, evaluating a script at each iteration, and collecting the results of each loop iteration into a new list.
The command \cmdlink{lexpr} is an extension of this concept, just calling \textit{lmap} and passing the input through the Tcl \textit{expr} command.

\begin{syntax}
\command{lexpr} \$varList \$list <\$varList \$list ...> \$expr
\end{syntax}
\begin{args}
\$varList ... & List(s) of variables to iterate with. \\
\$list ... & List(s) to iterate over. \\
\$expr & Tcl expression to evaluate at every loop iteration.
\end{args}
\begin{example}{Filtering a list}
\begin{lstlisting}
set numbers [range 10]
set odds [lexpr x $numbers {$x % 2 ? $x : [continue]}]; # only odd numbers
puts $odds
\end{lstlisting}
\tcblower
\begin{lstlisting}
1 3 5 7 9
\end{lstlisting}
\end{example}

\begin{example}{Adding three lists together}
\begin{lstlisting}
set x {1 2 3}
set y {2 9 2}
set z {5 -2 0}
puts [lexpr xi $x yi $y zi $z {$xi + $yi + $zi}]
\end{lstlisting}
\tcblower
\begin{lstlisting}
8 9 5
\end{lstlisting}
\end{example}

\clearpage
\subsection{List Statistics}
The commands \cmdlink{max}, \cmdlink{min}, \cmdlink{sum}, \cmdlink{product}, \cmdlink{mean}, \cmdlink{median}, \cmdlink{stdev} and \cmdlink{pstdev} compute the maximum, minimum, sum, product, mean, median, sample and population standard deviation of values in a list.
For more advanced statistics, check out the Tcllib math::statistics package.
\begin{syntax}
\command{max} \$list 
\end{syntax}
\begin{syntax}
\command{min} \$list 
\end{syntax}
\begin{syntax}
\command{sum} \$list
\end{syntax}
\begin{syntax}
\command{product} \$list
\end{syntax}
\begin{syntax}
\command{mean} \$list 
\end{syntax}
\begin{syntax}
\command{median} \$list 
\end{syntax}
\begin{syntax}
\command{stdev} \$list
\end{syntax}
\begin{syntax}
\command{pstdev} \$list
\end{syntax}
\begin{args}
\$list & List to compute statistic of. \\
\end{args}
\begin{example}{List Statistics}
\begin{lstlisting}
set list {-5 3 4 0}
foreach stat {max min sum product mean median stdev pstdev} {
    puts [list $stat [$stat $list]]
}
\end{lstlisting}
\tcblower
\begin{lstlisting}
max 4
min -5
sum 2
product 0
mean 0.5
median 1.5
stdev 4.041451884327381
pstdev 3.5
\end{lstlisting}
\end{example}
\clearpage
\subsection{Vector Algebra}
The dot product of two equal length vectors can be computed with \cmdlink{dot}.
The cross product of two vectors of length 3 can be computed with \cmdlink{cross}. 
\begin{syntax}
\command{dot} \$a \$b
\end{syntax}
\begin{syntax}
\command{cross} \$a \$b
\end{syntax}
\begin{args}
\$a & First vector. \\
\$b & Second vector.
\end{args}
\begin{example}{Dot and cross product}
\begin{lstlisting}
set x {1 2 3}
set y {-2 -4 6}
puts [dot $x $y]
puts [cross $x $y]
\end{lstlisting}
\tcblower
\begin{lstlisting}
8
24 -12 0
\end{lstlisting}
\end{example}
The norm, or magnitude, of a vector can be computed with \cmdlink{norm}.
\begin{syntax}
\command{norm} \$a <\$p>
\end{syntax}
\begin{args}
\$a & Vector to compute norm of. \\
\$p & Norm type. 1 is sum of absolute values, 2 is euclidean distance, and Inf is absolute maximum value. Default 2.
\end{args}
\begin{example}{Normalizing a vector}
\begin{lstlisting}
set x {3 4}
set x [lop $x / [norm $x]]
puts $x
\end{lstlisting}
\tcblower
\begin{lstlisting}
0.6 0.8
\end{lstlisting}
\end{example}
For more advanced vector algebra routines, check out the Tcllib math::linearalgebra package.

\clearpage
\section{2-Dimensional Lists (Matrices)}
A matrix is a two-dimensional list, or a list of row vectors.
This is consistent with the format used in the Tcllib math::linearalgebra package.
See the example below for how matrices are interpreted.
\begin{equation*}\label{eq:matrix_AB}
A=\begin{bmatrix}
2 & 5 & 1 & 3 \\
4 & 1 & 7 & 9 \\
6 & 8 & 3 & 2 \\
7 & 8 & 1 & 4
\end{bmatrix},\quad
B=\begin{bmatrix}
9 \\ 3 \\ 0 \\ -3
\end{bmatrix},\quad
C = \begin{bmatrix}
3 & 7 & -5 & -2
\end{bmatrix}
\end{equation*}
\begin{example}{Matrices and vectors}
\begin{lstlisting}
# Define matrices, column vectors, and row vectors
set A {{2 5 1 3} {4 1 7 9} {6 8 3 2} {7 8 1 4}}
set B {9 3 0 -3}
set C {{3 7 -5 -2}}
# Print out matrices (join with newline to print out each row)
puts "A ="
puts [join $A \n]
puts "B ="
puts [join $B \n]
puts "C ="
puts [join $C \n]
\end{lstlisting}
\tcblower
\begin{lstlisting}
A =
2 5 1 3
4 1 7 9
6 8 3 2
7 8 1 4
B =
9
3
0
-3
C =
3 7 -5 -2
\end{lstlisting}
\end{example}
\clearpage
\subsection{Generating Matrices}
The commands \cmdlink{zeros}, \cmdlink{ones}, and \cmdlink{eye} generate common matrices.
\begin{syntax}
\command{zeros} \$n \$m
\end{syntax}
\begin{syntax}
\command{ones} \$n \$m
\end{syntax}
\begin{args}
\$n & Number of rows \\
\$m & Number of columns
\end{args}
The command \cmdlink{eye} generates an identity matrix of a specified size.
\begin{syntax}
\command{eye} \$n
\end{syntax}
\begin{args}
\$n  & Size of identity matrix 
\end{args}

\begin{example}{Generating standard matrices}
\begin{lstlisting}
puts [zeros 2 3]
puts [ones 3 2]
puts [eye 3]
\end{lstlisting}
\tcblower
\begin{lstlisting}
{0 0 0} {0 0 0}
{1 1} {1 1} {1 1}
{1 0 0} {0 1 0} {0 0 1}
\end{lstlisting}
\end{example}
\clearpage


\subsection{Combining Matrices}
The commands \cmdlink{stack} and \cmdlink{augment} can be used to combine matrices, row or column-wise.
\begin{syntax}
\command{stack} \$mat1 \$mat2 ...
\end{syntax}
\begin{syntax}
\command{augment} \$mat1 \$mat2 ...
\end{syntax}
\begin{args}
\$mat1 \$mat2 ... & Arbitrary number of matrices to stack/augment (number of columns/rows must match)
\end{args}
The command \cmdlink{block} combines a matrix of matrices into a block matrix.
\begin{syntax}
\command{block} \$matrices
\end{syntax}
\begin{args}
\$matrices & Matrix of matrices.
\end{args}
\begin{example}{Combining matrices}
\begin{lstlisting}
set A [stack {{1 2}} {{3 4}}]
set B [augment {1 2} {3 4}]
set C [block [list [list $A $B] [list $B $A]]]
puts $A
puts $B
puts [join $C \n]; # prints each row on a new line
\end{lstlisting}
\tcblower
\begin{lstlisting}
{1 2} {3 4}
{1 3} {2 4}
1 2 1 3
3 4 2 4
1 3 1 2
2 4 3 4
\end{lstlisting}
\end{example}
\clearpage
\subsection{Matrix Transpose}
The command \cmdlink{transpose} simply swaps the rows and columns of a matrix. 
\begin{syntax}
\command{transpose} \$A
\end{syntax}
\begin{args}
\$A & Matrix to transpose, nxm.
\end{args}
Returns an mxn matrix.
\begin{example}{Transposing a matrix}
\begin{lstlisting}
puts [transpose {{1 2} {3 4}}]
\end{lstlisting}
\tcblower
\begin{lstlisting}
{1 3} {2 4}
\end{lstlisting}
\end{example}
\subsection{Matrix Multiplication}
The command \cmdlink{matmul} performs matrix multiplication for two matrices.
Inner dimensions must match.
\begin{syntax}
\command{matmul} \$A \$B
\end{syntax}
\begin{args}
\$A & Left matrix, nxq. \\
\$B & Right matrix, qxm. 
\end{args}
Returns an nxm matrix (or the corresponding dimensions from additional matrices)
\begin{example}{Multiplying a matrix}
\begin{lstlisting}
puts [matmul {{2 5 1 3} {4 1 7 9} {6 8 3 2} {7 8 1 4}} {9 3 0 -3}]
\end{lstlisting}
\tcblower
\begin{lstlisting}
24 12 72 75
\end{lstlisting}
\end{example}
\clearpage
\subsection{Miscellaneous Linear Algebra Routines}
The command \cmdlink{outerprod} takes the outer product of two vectors, $\bm{a} \otimes \bm{b} = \bm{a}\bm{b}^T$.
\begin{syntax}
\command{outerprod} \$a \$b
\end{syntax}
\begin{args}
\$a \$b & Vectors with lengths n and m. Returns a matrix, shape nxm.
\end{args}

The command \cmdlink{kronprod} takes the Kronecker product of two matrices, as shown in \eq\eqref{eq:kronprod}.
\begin{syntax}
\command{kronprod} \$A \$B
\end{syntax}
\begin{args}
\$A \$B & Matrices, shapes nxm and pxq. Returns a matrix, shape (np)x(mq).
\end{args}
\begin{equation}\label{eq:kronprod}
\bm{A} \otimes \bm{B} = \left[\begin{matrix}
a_{11}\bm{B} & ... & a_{1n}\bm{B} \\
\vdots & \ddots & \vdots \\
a_{n1}\bm{B} & ... & a_{nn}\bm{B}
\end{matrix}\right]
\end{equation}
\begin{example}{Outer product and Kronecker product}
\begin{lstlisting}
set A [eye 3]
set B [outerprod {1 2} {3 4}]
set C [kronprod $A $B]
puts [join $C \n]; # prints out each row on a new line
\end{lstlisting}
\tcblower
\begin{lstlisting}
3 4 0 0 0 0
6 8 0 0 0 0
0 0 3 4 0 0
0 0 6 8 0 0
0 0 0 0 3 4
0 0 0 0 6 8
\end{lstlisting}
\end{example}
For more advanced matrix algebra routines, check out the Tcllib math::linearalgebra package.
\clearpage
\subsection{Iteration Tools}
The commands \cmdlink{zip} zips two lists into a list of tuples, and \cmdlink{zip3} zip three lists into a list of triples. 
Lists must be the same length.
\begin{syntax}
\command{zip} \$a \$b
\end{syntax}
\begin{syntax}
\command{zip3} \$a \$b \$c
\end{syntax}
\begin{args}
\$a \$b \$c & Lists to zip together.
\end{args}
\begin{example}{Zipping and unzipping lists}
\begin{lstlisting}
# Zipping
set x [zip {A B C} {1 2 3}]
set y [zip3 {Do Re Mi} {A B C} {1 2 3}]
puts $x
puts $y
# Unzipping (using transpose)
puts [transpose $x]
\end{lstlisting}
\tcblower
\begin{lstlisting}
{A 1} {B 2} {C 3}
{Do A 1} {Re B 2} {Mi C 3}
{A B C} {1 2 3}
\end{lstlisting}
\end{example}
The command \cmdlink{cartprod} computes the Cartesian product of an arbitrary number of vectors, returning a matrix where the columns correspond to the input vectors and the rows correspond to all the combinations of the vector elements.
\begin{syntax}
\command{cartprod} \$a \$b ...
\end{syntax}
\begin{args}
\$a \$b ... & Arbitrary number of vectors to take Cartesian product of.
\end{args}

\begin{example}{Cartesian product}
\begin{lstlisting}
puts [cartprod {A B C} {1 2 3}]
\end{lstlisting}
\tcblower
\begin{lstlisting}
{A 1} {A 2} {A 3} {B 1} {B 2} {B 3} {C 1} {C 2} {C 3}
\end{lstlisting}
\end{example}

\clearpage