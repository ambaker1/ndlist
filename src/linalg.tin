# linalg.tcl
################################################################################
# Basic linear algebra routines
# Adapted from similar routines in math::linearalgebra package

# Copyright (C) 2023 Alex Baker, ambaker1@mtu.edu
# All rights reserved. 

# See the file "LICENSE" in the top level directory for information on usage, 
# redistribution, and for a DISCLAIMER OF ALL WARRANTIES.
################################################################################

# Define namespace and exported commands
namespace eval ::ndlist {
    namespace export range ones zeros eye; # Vector/matrix generation
    namespace export dot cross norm; # Vector algebra
    namespace export matmul transpose; # Matrix algebra
}

# range --
#
# Utility to generate integer range, great for use with foreach or lmap.
# 
# range $n
# range $start $stop
# range $start $stop $step
#
# Arguments:
# n:        Number of integers
# start:    Start of resultant range.
# stop:     End limit of resultant range.
# step:     Step size. Default 1 or -1, depending on direction.

proc ::ndlist::range {args} {
    # Switch for arity
    if {[llength $args] == 1} {
        # Basic case
        set n [lindex $args 0]
        if {![string is integer -strict $n] || $n < 0} {
            return -code error "n must be integer >= 0"
        }
        set start 0
        set stop [expr {$n - 1}]
        set step 1
    } elseif {[llength $args] == 2} {
        lassign $args start stop
        if {![string is integer -strict $start]} {
            return -code error "start must be integer"
        }
        if {![string is integer -strict $stop]} {
            return -code error "stop must be integer"
        }
        set step [expr {$stop > $start ? 1 : -1}]
    } elseif {[llength $args] == 3} {
        lassign $args start stop step
        if {![string is integer -strict $start]} {
            return -code error "start must be integer"
        }
        if {![string is integer -strict $stop]} {
            return -code error "stop must be integer"
        }
        if {![string is integer -strict $step]} {
            return -code error "step must be integer"
        }
    } else {
        return -code error "wrong # args: should be \"range n\",\
                \"range start stop\", or \"range start stop step\""
    }
    return [Range $start $stop $step]
}

# ones --
#
# Generate a tensor filled with ones
#
# Syntax:
# ones $n ...
# 
# Arguments:
# n ...         Dimensions of tensor    

proc ::ndlist::ones {args} {
    nrepeat 1 {*}$args
}

# zeros --
# 
# Generate a tensor filled with zeros
#
# Syntax:
# zeros $n ...
# 
# Arguments:
# n ...         Dimensions of tensor

proc ::ndlist::zeros {args} {
    nrepeat 0 {*}$args
}

# eye --
# 
# Generate an identity matrix
#
# Syntax:
# eye $n
# 
# Arguments:
# n             Size of matrix (nxn)

proc ::ndlist::eye {n} {
    set x [zeros $n $n]
    foreach i [range $n] {
        lset x $i $i 1
    }
    return $x
}

# dot --
#
# Dot product of two vectors.
#
# Syntax:
# dot $a $b
#
# Arguments:
# a b           Vectors, same length (length > 0)

proc ::ndlist::dot {a b} {
    # Check dimensions
    if {[llength $a] != [llength $b]} {
        return -code error "incompatible vector lengths"
    }
    sum [lmap ai $a bi $b {expr {$ai * $bi}}]
}

# cross --
# 
# Cross product of two 3D vectors, vec1 vec2
#
# Arguments:
# a:            First vector, 3D
# b:            Second vector, 3D

proc ::ndlist::cross {a b} {
    if {[llength $a] != 3 || [llength $b] != 3} {
        return -code error "cross-product only defined for 3D vectors"
    }
    lassign $a a1 a2 a3
    lassign $b b1 b2 b3
    set c1 [expr {double($a2*$b3 - $a3*$b2)}]
    set c2 [expr {double($a3*$b1 - $a1*$b3)}]
    set c3 [expr {double($a1*$b2 - $a2*$b1)}]
    return [list $c1 $c2 $c3]
}

# norm --
# 
# Norm of vector (returns double)
#
# Arguments:
# vector:       Vector
# p:            Norm type. Default 2 (euclidean distance).

proc ::ndlist::norm {vector {p 2}} {
    switch $p {
        1 { # Sum of absolute values
            set norm 0.0
            foreach value $vector {
                set norm [expr {$norm+abs($value)}]
            }
            return $norm
        }
        2 { # Euclidean (use hypot function to avoid overflow)
            set norm 0.0
            foreach value $vector {
                set norm [expr {hypot($value,$norm)}]
            }
            return $norm
        }
        Inf { # Absolute maximum of the vector
            return [expr {double([max [abs $vector]])}]
        }
        default { # Arbitrary integer norm
            if {![string is integer -strict $p] || $p <= 0} {
                return -code error "p must be integer > 0"
            }
            set sum 0.0
            foreach value $vector {
                set sum [expr {$sum+$value**$p}]
            }
            return [expr {pow($sum,1.0/$p)}]
        }
    }
}

# matmul --
#
# Multiplies two matrices. Must agree in dimension.
#
# Arguments:
# A B           Matrices, matching inner dimensions
#
# Returns a nxm matrix, by computing the dot-product of rows and columns

proc ::ndlist::matmul {A B} {
    # Check dimensions
    if {[llength [lindex $A 0]] != [llength $B]} {
        return -code error "incompatible matrix dimensions"
    }
    # Transpose B matrix for easy multiplication
    set BT [transpose $B]
    # Perform dot-product of all rows and columns
    lmap rowA $A {
        lmap colB $BT {
            dot $rowA $colB
        }
    }
}

# transpose --
# 
# Transpose a matrix
# Adapted from math::linearalgebra::transpose and lsearch example on Tcl wiki
# written by MJ (https://wiki.tcl-lang.org/page/Transposing+a+matrix)
# 
# Arguments:
# matrix:           Matrix to transpose

proc ::ndlist::transpose {matrix} {
    set n [llength $matrix]
    # Null case
    if {$n == 0} {
        return
    }
    set m [llength [lindex $matrix 0]]
    if {$n == 1 && $m == 1} {
        return $matrix
    } elseif {$n > $m} {
        set i -1
        lmap x [lindex $matrix 0] {
            lsearch -all -inline -subindices -index [incr i] $matrix *
        }
    } else {
        set i -1
        lmap x [lindex $matrix 0] {
            incr i
            lmap row $matrix {lindex $row $i}
        }
    }
}
