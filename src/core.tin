# core.tcl
################################################################################
# Core procedures for ND list creation, metadata, and indexing/modification

# Copyright (C) 2023 Alex Baker, ambaker1@mtu.edu
# All rights reserved. 

# See the file "LICENSE" in the top level directory for information on usage, 
# redistribution, and for a DISCLAIMER OF ALL WARRANTIES.
################################################################################

# Define namespace and exported commands
namespace eval ::ndlist {    
    namespace export ndlist nrepeat nexpand; # Creation
    namespace export nshape nsize; # Metadata access
    namespace export nget nset nreplace; # Access/modification
    namespace export ninsert nstack; # Combination
    namespace export nflatten nreshape nswapaxes; # Manipulation
    namespace export napply nreduce nmap nexpr nop; # Mapping
}

# NDLIST CREATION
################################################################################

# ndlist --
#
# Validate that the list is an ndlist of specified dims, and return the ndlist.
#
# Syntax:
# ndlist $nd $value
#
# Arguments:
# nd            Number of dimensions (e.g. 1D, 2D, etc.)
# value         Value to create an ndlist from.

proc ::ndlist::ndlist {nd value} {
    # Interpret input
    set ndims [GetNDims $nd]
    set ndlist $value
    # Check if it is a valid ndlist, and try to shape it into one.
    if {![IsShape $ndlist {*}[GetShape $ndims $ndlist]]} {
        return -code error "not a valid ndlist"
    }
    return $ndlist
}

# nrepeat --
#
# Create an ndlist filled with one value
#
# Syntax:
# nrepeat $value $arg ...
#
# Arguments:
# value         Value to repeat
# arg ...       Shape of ndlist

proc ::ndlist::nrepeat {value args} {
    set ndlist $value
    foreach n [lreverse $args] {
        set ndlist [lrepeat $n $ndlist]
    }
    return $ndlist
}

# GetNDims --
#
# Get dimensionality from ND string (uses regex pattern).
# Either a single digit or with a "D" after.
# e.g. "0" or "0D", or "3" or "3d"
# Returns error if invalid syntax
#
# Syntax:
# GetNDims $nd
#
# Arguments:
# nd        Number of dimensions (e.g. 1D, 2D, etc.)

proc ::ndlist::GetNDims {nd} {
    if {![IsNDType $nd]} {
        return -code error "invalid ND syntax"
    }
    string trimright $nd {dD}
}

# IsNDType --
#
# Returns whether an input is an ND string
#
# Syntax:
# IsNDType $arg
#
# Arguments:
# arg:          Argument to check

proc ::ndlist::IsNDType {arg} {
    regexp {^(0|[1-9]\d*)[dD]?$} $arg
}

# IsShape --
#
# Verify that the ndlist is of the specified shape
#
# Syntax:
# IsShape $ndlist $n $m ...
#
# Arguments:
# ndlist        ndlist to check
# n m ...       shape of ndlist

proc ::ndlist::IsShape {ndlist args} {
    # Scalar base case
    if {[llength $args] == 0} {
        return 1
    }
    # Interpret input
    set args [lassign $args n]
    # Vector base case
    if {[llength $ndlist] != $n} {
        return 0
    }
    # Recursion
    foreach ndrow $ndlist {
        if {![IsShape $ndrow {*}$args]} {
            return 0
        }
    }
    return 1
}

# GetShape --
#
# Private procedure to get list of dimensions of an ndlist along first index
#
# Syntax:
# GetShape $ndims $ndlist
#
# Arguments:
# ndims         Number of dimensions
# ndlist        ND list to get dimensions from

proc ::ndlist::GetShape {ndims ndlist} {
    # Get list of dimensions (along first index)
    set dims ""
    foreach i [lrepeat $ndims {}] {
        lappend dims [llength $ndlist]
        set ndlist [lindex $ndlist 0]
    }
    return $dims
}

# nexpand --
#
# Expand an ndlist to compatible dimensions.
# A dimension of an ndlist can be expanded if it has dimension 1
#
# Syntax:
# nexpand $ndlist $n1 $n2 ...
#
# Arguments:
# ndlist        ND list to expand
# n1 n2 ...     New dimensions

proc ::ndlist::nexpand {ndlist args} {    
    set dims1 $args
    set dims0 [GetShape [llength $dims1] $ndlist]
    foreach dim0 $dims0 dim1 $dims1 {
        if {$dim0 != $dim1} {
            return [RecExpand $ndlist $dims0 $dims1]
        }
    }
    return $ndlist
}

# RecExpand --
#
# Recursive handler for nexpand. 
# Expands a compatible ndlist (dimensions must match or be unity) 
# For example, 1x1, 1x4, 4x1, and 5x4 are all compatible with 5x4.
#
# Syntax:
# RecExpand $ndlist $dims0 $dims1
#
# Arguments:
# ndlist        ND list to expand
# dims0         Old dimensions list
# dims1         New dimensions list

proc ::ndlist::RecExpand {ndlist dims0 dims1} {
    # Switch for base cases
    if {[llength $dims0] == 0} {
        return $ndlist
    } elseif {[llength $dims0] == 1} {
        return [Expand $ndlist $dims0 $dims1]
    }
    # Strip dimension from args
    set dims0 [lassign $dims0 n0]
    set dims1 [lassign $dims1 n1]
    if {$n0 != $n1} {
        lrepeat $n1 [RecExpand [lindex $ndlist 0] $dims0 $dims1]
    } else {
        lmap ndrow $ndlist {
            RecExpand $ndrow $dims0 $dims1
        }
    }
}

# Expand --
#
# Base case for RecExpand. Throws error if dimensions are incompatible
#
# Syntax:
# Expand $list $n0 $n1
#
# Arguments:
# list          List to expand
# n0            Length of list
# n1            New length of list

proc ::ndlist::Expand {list n0 n1} {
    if {$n0 == $n1} {
        return $list
    } elseif {$n0 == 1} {
        return [lrepeat $n1 [lindex $list 0]]
    } else {
        return -code error "incompatible dimensions"
    }
}

# NDLIST METADATA
################################################################################

# nshape --
# 
# Get shape of ndlist
#
# Syntax:
# nshape $nd $ndlist <$axis>
#
# Arguments:
# nd                Number of dimensions (e.g. 1D, 2D, etc.)
# ndlist            ND list to get dimensions of
# axis              Axis to get dimension along. Blank for all.

proc ::ndlist::nshape {nd ndlist {axis ""}} {
    # Interpret and validate input
    set ndims [GetNDims $nd]
    if {![string is integer $axis]} {
        return -code error "axis must be integer"
    }
    # Switch for output type
    if {$axis eq ""} {
        return [GetShape $ndims $ndlist]
    } elseif {$axis >= 0 && $axis < $ndims} {
        # Get single dimension (along first index)
        return [llength [lindex $ndlist {*}[lrepeat $axis 0]]]
    } else {
        return -code error "axis must be between 0 and [expr {$ndims - 1}]"
    }
}

# nsize --
#
# Get the size of an ndlist (number of elements, product of the shape)
# For rank 0, it returns blank.
#
# Syntax:
# nsize $nd $ndlist
#
# Arguments:
# nd:               Number of dimensions (e.g. 1D, 2D, etc.)
# ndlist:           ND list to get dimensions of

proc ::ndlist::nsize {nd ndlist} {
    set ndims [GetNDims $nd]
    # Scalar case (no size)
    if {$ndims == 0} {
        return
    }
    # Get size (product of shape)
    return [product [GetShape $ndims $ndlist]]
}

# NDLIST ACCESS/MODIFICATION
################################################################################

# nget --
# 
# Get portion of ndlist using ndlist index notation.
#
# Syntax:
# nget $ndlist $i1 $i2 ...
#
# Arguments:
# ndlist        ND list value
# i1 i2 ...     Separate arguments for index dimensions

proc ::ndlist::nget {ndlist args} {
    # Get number of dimensions
    set indices $args
    set ndims [llength $indices]
    # Scalar case
    if {$ndims == 0} {
        return $ndlist
    }
    # Parse indices
    set dims [GetShape $ndims $ndlist]
    set iArgs [lassign [ParseIndices $indices $dims] iDims iLims]
    # Process limits and dimensions
    foreach dim $dims iLim $iLims iDim $iDims {
        if {$iLim >= $dim} {
            return -code error "index out of range"
        }
    }
    # Return ndims and the sublist
    return [RecGet $ndlist {*}$iArgs]
}

# RecGet --
#
# Private recursive handler for nget
#
# Syntax:
# RecGet $ndlist $iType $iList ...
# 
# Arguments:
# ndlist                ndlist to get values from
# iType, iList, ...     Index type and corresponding list. See ParseIndex.

proc ::ndlist::RecGet {ndlist iType iList args} {
    # Base case
    if {[llength $args] == 0} {
        return [Get $ndlist $iType $iList]
    }
    # Flatten for "S" case
    if {$iType eq "S"} {
        RecGet [Get $ndlist $iType $iList] {*}$args
    } else {
        lmap ndrow [Get $ndlist $iType $iList] {
            RecGet $ndrow {*}$args
        }
    }
}

# Get --
#
# Base case for RecGet
#
# Syntax:
# Get $list $iType $iList
#
# Arguments:
# list          List to get values from.
# iType         Index type. See ParseIndex.
# iList         Index list corresponding with index type. See ParseIndex

proc ::ndlist::Get {list iType iList} {
    # Switch for index type
    switch $iType {
        A { # All indices
            return $list
        }
        L { # List of indices
            return [lmap i $iList {
                lindex $list $i
            }]
        }
        R { # Range of indices
            lassign $iList i1 i2
            if {$i2 >= $i1} {
                return [lrange $list $i1 $i2]
            } else {
                return [lreverse [lrange $list $i2 $i1]]
            }
        }
        S { # Single index (flatten)
            set i [lindex $iList 0]
            return [lindex $list $i]
        }
    }
}

# GetNewNDims --
#
# Using the slice index style, return the number of dimensions of the new list.
#
# Syntax:
# GetNewNDims $indices
#
# Arguments:
# indices       List of index inputs

proc ::ndlist::GetNewNDims {indices} {
    llength [lsearch -all -not -index 0 $indices {*\*}]
}

# ParseIndices --
# 
# Loop through index inputs - returning required information for getting/setting
# 
# Returns a list - iDim then iArgs, where iArgs is a key-value list
# iDims iLims iType iList iType iList ...

proc ::ndlist::ParseIndices {inputs dims} {
    set iDims ""; # dimensions of indexed region
    set iLims ""; # Maximum indices for indexed region
    set iArgs ""; # paired list of index type and index list (meaning varies)
    foreach input $inputs dim $dims {
        lassign [ParseIndex $input $dim] iDim iLim iType iList 
        lappend iDims $iDim
        lappend iLims $iLim
        lappend iArgs $iType $iList
    }
    return [list $iDims $iLims {*}$iArgs]
}

# ParseIndex --
# 
# Used for parsing index input (i.e. list of indices, range 0:10, etc)
# Returns list, with first element being the index input type, and the remaining
# arguments being the index integers.
# Returns error if out of range

# Returns:
# iDim:     Dimension of indexed range (e.g. number of indices)
# iLim:     Largest index in indexed range
# iType:    Type of index
#   A:      All indices
#   R:      Range of indices
#   L:      List of indices 
#   S:      Single index (flattens array, iDim = 0)
# iList:    Depends on iType. For range, i1 and i2

proc ::ndlist::ParseIndex {input n} {
    # Check length of input
    if {[llength $input] == 1} {
        # Single index, colon, or range notation
        set index [lindex $input 0]
        if {$index eq {:}} {
            # All index notation (asterisk)
            set iType A
            set iList ""
            set iDim $n
            set iLim [expr {$n - 1}]
        } elseif {[string index $index end] eq {*}} {
            # Single index notation (flatten along this dimension)
            set i [Index2Integer [string range $index 0 end-1] $n]
            set iType S
            set iList $i
            set iDim 0; # flattens
            set iLim $i
        } elseif {[string match *:* $index]} {
            # Range notation (slice)
            set parts [split $index :]
            if {[llength $parts] == 2} {
                # Simple range
                lassign $parts i1 i2
                set i1 [Index2Integer $i1 $n]
                set i2 [Index2Integer $i2 $n]
                set iType R
                set iList [list $i1 $i2]
                if {$i2 >= $i1} {
                    # Forward range
                    set iDim [expr {$i2 - $i1 + 1}]
                    set iLim $i2
                } else {
                    # Reverse range
                    set iDim [expr {$i1 - $i2 + 1}]
                    set iLim $i1
                }
            } elseif {[llength $parts] == 3} {
                # Skipped range
                lassign $parts i1 step i2
                set i1 [Index2Integer $i1 $n]
                set i2 [Index2Integer $i2 $n]
                if {![string is integer -strict $step]} {
                    return -code error "invalid range index notation"
                }
                # Deal with range case
                if {$i2 >= $i1} {
                    if {$step == 1} {
                        # Forward range
                        set iType R
                        set iList [list $i1 $i2]
                        set iDim [expr {$i2 - $i1 + 1}]
                        set iLim $i2; # end of range
                    } else {
                        # Forward stepped range (list)
                        set iType L
                        set iList [Range $i1 $i2 $step]
                        set iDim [llength $iList]
                        set iLim [lindex $iList end]; # end of list
                    }
                } else {
                    if {$step == -1} {
                        # Reverse range
                        set iType R
                        set iList [list $i1 $i2]
                        set iDim [expr {$i1 - $i2 + 1}]
                        set iLim $i1; # start of range
                    } else {
                        # Reverse stepped range (list)
                        set iType L
                        set iList [Range $i1 $i2 $step]
                        set iDim [llength $iList]
                        set iLim [lindex $iList 0]; # start of list
                    }
                }
            } else {
                return -code error "invalid range index notation"
            }
        } else {
            # Single index list (do not flatten)
            set i [Index2Integer $index $n]
            set iType L
            set iList $i
            set iDim 1
            set iLim $i
        }; # end parse single index
    } else {
        # List of indices (user entered)
        set iType L
        set iList [lmap index $input {Index2Integer $index $n}]
        set iDim [llength $iList]
        set iLim 0
        foreach i $iList {
            if {$i > $iLim} {
                set iLim $i
            }
        }
    }
    # Check if out of range
    if {$iLim >= $n} {
        return -code error "index out of range"
    }
    # Return list of results
    return [list $iDim $iLim $iType $iList]
}

# Index2Integer --
#
# Private function, converts end+-integer index format into integer
# Negative indices get converted, such that -1 is end, -2 is end-1, etc.
#
# Arguments:
# index:        Tcl index format (integer?[+-]integer? or end?[+-]integer?)
# n:            Length of list to index

proc ::ndlist::Index2Integer {index n} {
    # Default case (skip regexp, much faster)
    if {[string is integer -strict $index]} {
        set i $index
    } else {
        # Check if index is valid format
        set match [regexp -inline {^(end|[+-]?[0-9]+)([+-][0-9]+)?$} $index]
        if {[llength $match] == 0} {
            return -code error "bad index \"$index\": must be\
                    integer?\[+-\]integer? or end?\[+-\]integer?"
        }
        # Convert end to n-1 if needed
        set base [lindex $match 1]
        if {$base eq {end}} {
            set base [expr {$n - 1}]
        }
        # Handle offset
        set offset [lindex $match 2]
        if {$offset eq {}} {
            set i $base
        } else {
            set i [expr {$base + $offset}]
        }
    }
    # Handle negative index (from end)
    if {$i < 0} {
        set i [expr {$i % $n}]
    }
    return $i
}

# Range --
#
# Private procedure for integer range
#
# Syntax:
# Range $start $stop $step
#
# Arguments:
# start     Start of resultant range.
# stop      End limit of resultant range.
# step      Step size.

proc ::ndlist::Range {start stop step} {
    # Avoid divide by zero
    if {$step == 0} {
        return ""
    }
    # Get range length
    set n [expr {($stop - $start)/$step + 1}]
    # Basic cases
    if {$n <= 0} {
        return ""
    }
    if {$n == 1} {
        return $start
    }
    # General case (generate list)
    set i [expr {$start - $step}]
    lmap x [lrepeat $n {}] {incr i $step}
}

# nset --
# 
# Set portion of ndlist using ndlist index notation.
# Simply calls nreplace to set new value of ndlist.
#
# Syntax:
# nset $varName $i1 $i2 ... $sublist
#
# Arguments:
# varName       Variable where a valid ndlist is stored
# i1 i2 ...     Separate arguments for index dimensions
# sublist       Sublist to set (must agree in dimension or unity)
#               If blank, removes elements (must remove only along one axis)

# Examples:
# > set a {1 2 3 4}
# > nset a 0:1 {foo bar}
# > puts $a
# foo bar 3 4

proc ::ndlist::nset {varName args} {
    upvar 1 $varName ndlist
    # Initialize ndlist if not set yet
    if {![info exists ndlist]} {
        set ndlist ""
    }
    set ndlist [nreplace $ndlist {*}$args]
    return $ndlist
}

# nreplace --
#
# Replace portion of ndlist - return new list, same dimension. 
#
# Syntax:
# nreplace $ndlist $i1 $i2 ... $sublist
# 
# Arguments:
# ndlist        Valid ndlist
# i1 i2 ...     Separate arguments for index dimensions
# sublist       Sublist to replace with (must agree in dimension or unity)
#               If blank, removes elements (must remove only along one axis)

proc ::ndlist::nreplace {ndlist args} {
    # Interpret input
    set indices [lrange $args 0 end-1]; # $i ...
    set sublist [lindex $args end]
    # Get number of dimensions
    set ndims [llength $indices]
    # Scalar case
    if {$ndims == 0} {
        return $sublist
    }
    # Parse indices
    set dims [GetShape $ndims $ndlist]
    set iArgs [lassign [ParseIndices $indices $dims] iDims iLims]
    # Switch for replacement type (removal or substitution)
    if {[llength $sublist] == 0} {
        # Removal/deletion    
        # Get axis to delete along
        set axis -1
        set i 0
        foreach {iType iList} $iArgs {
            if {$iType ne "A"} {
                if {$axis != -1} {
                    return -code error "can only delete along one axis"
                }
                set axis $i
            }
            incr i
        }
        # Trivial case (removal of all)
        if {$axis == -1} {
            return ""
        }
        # Get axis information
        set dim [lindex $dims $axis]
        set iDim [lindex $iDims $axis]
        set iLim [lindex $iLims $axis]
        set iType [lindex $iArgs [expr {$axis * 2}]]
        set iList [lindex $iArgs [expr {$axis * 2 + 1}]]
        # Handle "L" case, indices must be sorted and unique.
        if {$iType eq "L"} {
            set iList [lsort -integer -decreasing -unique $iList]
            set iDim [llength $iList]
        } elseif {$iType eq "S"} {
            set iDim 1; # Single removal
        }
        # Get new dimension along removal axis
        set subdim [expr {$dim - $iDim}]
        # Check for null case
        if {$subdim == 0} {
            return ""
        }
        # Get new dimensions
        set subdims [lreplace $dims $axis $axis $subdim]
        # Call recursive removal handler and return with new dimensions
        set ndlist [RecRemove $ndlist $axis $iType $iList]
    } else {
        # Substitution/replacement
        # Process input dimensions
        set subdims ""
        foreach iDim $iDims {
            if {$iDim > 0} {
                lappend subdims $iDim
            }
        }
        # Expand sublist if needed based on index dimensions.
        set sublist [nexpand $sublist {*}$subdims]
        # Call recursive replacement handler
        set ndlist [RecReplace $ndlist $sublist {*}$iArgs]
    }
    # Return updated list
    return $ndlist
}

# RecRemove --
#
# Private recursive handler for removing elements from ndlists
#
# Syntax:
# RecRemove $ndlist $axis $iType $iList
#
# Arguments:
# ndlist:       ndlist to modify
# axis:         Axis to remove on
# iType         Index type, "A" not allowed. See ParseIndex.
# iList         Index list. See ParseIndex.

proc ::ndlist::RecRemove {ndlist axis iType iList} {
    # Base case
    if {$axis == 0} {
        return [Remove $ndlist $iType $iList]
    }
    # Recursion case
    incr axis -1
    set ndlist [lmap ndrow $ndlist {
        RecRemove $ndrow $axis $iType $iList
    }]
    return $ndlist
}

# Remove --
#
# Base case for RecRemove
#
# Syntax:
# Remove $list $iType $iList
# 
# Arguments:
# list          List to remove elements from
# iType         Index type, "A" not allowed. See ParseIndex.
# iList         Index list. See ParseIndex.

proc ::ndlist::Remove {list iType iList} {
    # Base case
    switch $iType {
        L { # Subset of indices
            foreach i $iList {
                set list [lreplace $list $i $i]
            }
        }
        R { # Range of indices
            lassign $iList i1 i2
            if {$i2 >= $i1} {
                set list [lreplace $list $i1 $i2]
            } else {
                set list [lreplace $list $i2 $i1]
            }
        }
        S { # Single index (same as L for removal)
            set i [lindex $iList 0]
            set list [lreplace $list $i $i]
        }
    }
    return $list
}

# RecReplace --
#
# Private recursive handler for nreplace
#
# Syntax:
# RecReplace $ndlist $sublist $iType $iList ...
#
# Arguments:
# ndlist        ndlist to modify (pass by value)
# sublist       ndlist to substitute at specified indices
# iType ...     Index type. See ParseIndex.
# iList ...     Index list. See ParseIndex.

proc ::ndlist::RecReplace {ndlist sublist iType iList args} {
    # Base case
    if {[llength $args] == 0} {
        return [Replace $ndlist $sublist $iType $iList]
    }
    # Get portion of ndlist to perform substitution
    set ndrows [Get $ndlist $iType $iList]
    # Recursively replace elements in sublist
    if {$iType eq "S"} {
        set sublist [RecReplace $ndrows $sublist {*}$args]
    } else {
        set sublist [lmap ndrow $ndrows subrow $sublist {
            RecReplace $ndrow $subrow {*}$args
        }]
    }
    # Finally, replace at this level.
    return [Replace $ndlist $sublist $iType $iList]
}

# Replace --
#
# Base case (list) for RecReplace 
#
# Syntax:
# Replace $list $sublist iType iList
#
# Arguments:
# list          list to modify (pass by value)
# sublist       list of values to substitute at specified indices
# iType         Index type. See ParseIndex.
# iList         Index list. See ParseIndex.

proc ::ndlist::Replace {list sublist iType iList} {
    # Switch for index type
    switch $iType {
        A { # All indices
            set list $sublist
        }
        L { # Subset of indices
            foreach i $iList subrow $sublist {
                lset list $i $subrow
            }
        }
        R { # Range of indices
            lassign $iList i1 i2
            if {$i2 >= $i1} {
                set list [lreplace $list $i1 $i2 {*}$sublist]
            } else {
                set list [lreplace $list $i2 $i1 {*}[lreverse $sublist]]
            }
        }
        S { # Single index (flatten)
            set i [lindex $iList 0]
            lset list $i $sublist
        }
    }
    return $list
}

# NDLIST COMBINATION
################################################################################

# ninsert --
#
# Insert ndlists in other ndlists, verifying that dimensions are compatible.
#
# Syntax:
# ninsert $nd $ndlist $index $sublist <$axis>
#
# Arguments:
# nd            Number of dimensions
# ndlist        ndlist to modify
# index         Index to insert at
# sublist       ndlist to insert
# axis          Axis to insert along. Default 0.

proc ::ndlist::ninsert {nd ndlist index sublist {axis 0}} {
    # Get number of dimensions and ndlist shape
    set ndims [GetNDims $nd]
    # Check validity of ndims/axis
    if {![string is integer -strict $axis]} {
        return -code error "axis must be integer"
    }
    if {$axis < 0 || $axis >= $ndims} {
        return -code error "axis out of range"
    }
    # Verify that dimensions agree on all axes except for the insert axis
    set dims [GetShape $ndims $ndlist]
    set subdims [GetShape $ndims $sublist]
    set i 0
    foreach dim $dims subdim $subdims {
        if {$dim ne $subdim && $i != $axis} {
            return -code error "incompatible dimensions along axis $i"
        }
        incr i
    }
    # Perform recursive insertion
    return [RecInsert $ndlist $axis $index $sublist]
}

# RecInsert --
# 
# Recursive handler for ninsert (after dimensions were checked)
#
# Syntax:
# RecInsert $ndlist $axis $index $arg...
#
# Arguments:
# ndlist        ndlist to modify
# axis          axis to insert along
# index         index to insert at
# arg...        sublists to insert.

proc ::ndlist::RecInsert {ndlist axis index sublist} {
    # Base case
    if {$axis == 0} {
        return [linsert $ndlist $index {*}$sublist]
    }
    # Recursion
    incr axis -1
    lmap ndrow $ndlist subrow $sublist {
        RecInsert $ndrow $axis $index $subrow
    }
}

# nstack --
#
# Combine ndlists (special case of ninsert)
#
# Syntax:
# nstack $nd $ndlist1 $ndlist2 <$axis>
#
# Arguments:
# nd                Number of dimensions
# ndlist1 ndlist2   ND lists to stack
# axis              Axis to stack along. Default 0.

proc ::ndlist::nstack {nd ndlist1 ndlist2 {axis 0}} {
    ninsert $nd $ndlist1 end $ndlist2 $axis
}

# NDLIST TRANSFORMATION
################################################################################

# nflatten --
#
# Flatten an ndlist to a vector (1D)
# If nd is 0D, it creates a 1D list.
#
# Syntax:
# nflatten $nd $ndlist
#
# Arguments:
# nd            Number of dimensions (e.g. 1D, 2D, etc.)
# ndlist        ND list to reshape dimensions of

proc ::ndlist::nflatten {nd ndlist} {
    # Interpret input and get dimensionality
    set ndims [GetNDims $nd]
    # Handle scalar case
    if {$ndims == 0} {
        # Create a one-element list
        return [list $ndlist]
    }
    # Flatten the ndlist
    set vector $ndlist
    for {set i 1} {$i < $ndims} {incr i} {
        set vector [concat {*}$vector]
    }
    return $vector
}

# nreshape --
#
# Reshape an ndlist to specified dimensions.
#
# Syntax:
# nreshape $nd $ndlist $arg...
#
# Arguments:
# nd            Number of dimensions (e.g. 1D, 2D, etc.)
# ndlist        ND list to reshape dimensions of
# arg...        New shape (and dimensions)

proc ::ndlist::nreshape {nd ndlist args} {
    # Get flattened ndlist
    set vector [nflatten $nd $ndlist]
    # Switch for target dimensionality
    set ndims [llength $args]
    if {$ndims == 0} {
        # Scalar (same as flatten)
        set newlist $vector
    } elseif {$ndims == 1} {
        # Vector (verify length, and then return vector)
        if {[lindex $args 0] != [llength $vector]} {
            return -code error "incompatible dimensions"
        }
        set newlist $vector
    } else {
        # Reshape into matrix or higher-dimension tensor
        set newlist [RecReshape $vector {*}$args] 
    }
    return $newlist
}

# RecReshape --
#
# Recursive handler for reshaping an ndlist
#
# Syntax:
# RecReshape $vector $n $m <$arg...>
#
# Arguments:
# vector        Vector to reshape into a matrix
# n m           Matrix dimensions
# arg...        Dimensions of each matrix element. Default scalar.

proc ::ndlist::RecReshape {vector n m args} {
    # Get size of each "row"
    set M $m
    foreach arg $args {
        set M [expr {$M * $arg}]
    }
    # Get total size and compare with vector length
    set size [expr {$n*$M}]
    if {[llength $vector] != $size} {
        return -code error "incompatible dimensions"
    }
    # Create matrix
    set i -$M
    set j -1
    set matrix [lmap x [lrepeat $n {}] {
        lrange $vector [incr i $M] [incr j $M]
    }]
    # Base case
    if {[llength $args] == 0} {
        return $matrix
    }
    # Recursion
    lmap row $matrix {
        RecReshape $row $m {*}$args
    }
}

# nswapaxes --
#
# Swaps axes
#
# Syntax:
# nswapaxes $nd $ndlist $axis1 $axis2
#
# Arguments:
# nd            Number of dimensions
# ndlist        ND list to manipulate
# axis1         Axis to swap with axis 2
# axis2         Axis to swap with axis 1

proc ::ndlist::nswapaxes {nd ndlist axis1 axis2} {
    # Get axes in order
    lassign [lsort -integer [list $axis1 $axis2]] axis1 axis2
    # Get dimensions and check axes
    set ndims [GetNDims $nd]
    if {$axis1 < 0 || $axis2 >= $ndims} {
        return -code error "axes out of range"
    }
    # Trivial case (same axis)
    if {$axis1 == $axis2} {
        return $ndlist
    }
    RecSwapAxes $ndlist $axis1 $axis2
}

# RecSwapAxes --
# 
# Recursive handler for ntranspose (after axes are checked)
#
# Arguments:
# ndlist:           ND list to manipulate
# axis1:            Axis to swap with axis 2
# axis2:            Axis to swap with axis 1 (must be greater than axis2)

proc ::ndlist::RecSwapAxes {ndlist axis1 axis2} {
    # Check if at axis to swap
    if {$axis1 == 0} {
        # First transpose
        set ndlist [transpose $ndlist]; # (ijk -> jik)
        # Base case
        if {$axis2 == 1} {
            return $ndlist
        }
        # Recursion (pass axis1 to axis2 position, and axis2 to axis1+1)
        incr axis2 -1
        set ndlist [lmap ndrow $ndlist {
            set ndrow [RecSwapAxes $ndrow $axis1 $axis2]; # (jik -> jki)
        }]
        # Final transpose
        return [transpose $ndlist]; # (jki -> kji)
    }
    # Simple recursion to get to first swap axis
    incr axis1 -1
    incr axis2 -1
    lmap ndrow $ndlist {
        RecSwapAxes $ndrow $axis1 $axis2
    }
}

# NDLIST MAPPING
################################################################################

# napply --
#
# Apply a function to a ND List
#
# Syntax:
# napply $nd $command $ndlist $arg ...
#
# Arguments:
# nd                Number of dimensions (e.g. 1D, 2D, etc.)
# command           Command prefix
# ndlist            ND list to iterate over
# arg ...           Additional arguments to append to command.

proc ::ndlist::napply {nd command ndlist args} {
    RecApply [GetNDims $nd] $command $ndlist {*}$args
}

# RecApply --
#
# Recursive handler for napply
#
# Syntax:
# RecApply $ndims $command $ndlist $arg...
# 
# Arguments:
# ndims             Number of dimensions at the current recursion level.
# command           Command prefix
# ndlist            ND list to iterate over
# arg...            Additional arguments to append to command.

proc ::ndlist::RecApply {ndims command ndlist args} {
    # Base case
    if {$ndims == 0} {
        return [eval [linsert $command end $ndlist {*}$args]]
    }
    # Recursion
    incr ndims -1
    lmap ndrow $ndlist {
        RecApply $ndims $command $ndrow {*}$args
    }
}

# nreduce --
#
# Use a reducing function to process an ND list along an axis.
# Function must take a 1D list as an input and return a value.
#
# Syntax:
# nreduce $nd $command $ndlist <$axis> <$arg ...>
#
# Arguments:
# nd                Number of dimensions (e.g. 1D, 2D, etc.)
# command           Function to apply along axis.
# ndlist            ND list to reduce.
# axis              Axis to reduce along over. Default 0.
# arg ...           Additional arguments to append to command.
# 
# Example:
# nreduce 2 max $x; # Gets maximum values for each column.
# nreduce 2 max $x 1; # Gets maximum values for each row.

proc ::ndlist::nreduce {nd command ndlist {axis 0} args} {
    # Interpret input
    set ndims [GetNDims $nd]
    if {$ndims == 0} {
        return -code error "cannot reduce a scalar"
    }
    if {![string is integer -strict $axis]} {
        return -code error "expected integer, got \"$axis\""
    }
    if {$axis < 0 || $axis >= $ndims} {
        return -code error "axis out of range"
    }
    # Move axis to reduce to back of ND list
    set ndlist [MoveAxisToBack $ndims $ndlist $axis] 
    # Reduce the ND list.
    napply [incr ndims -1] $command $ndlist {*}$args
}

# MoveAxisToBack --
#
# Private recursive function for moving an axis to the back of the ND list.
#
# Syntax:
# MoveAxisToBack $ndims $ndlist $axis
#
# Arguments:
# ndims             Number of dimensions
# ndlist            ND list to iterate over
# axis              Axis to move to back

proc ::ndlist::MoveAxisToBack {ndims ndlist axis} {
    # Base case
    if {$ndims == 1} {
        return $ndlist
    }
    # Recursion
    incr ndims -1
    if {$axis == 0} {
        set ndlist [transpose $ndlist]; # (ijk -> jik)
    } else {
        incr axis -1
    }
    lmap ndrow $ndlist {
        MoveAxisToBack $ndims $ndrow $axis; # (jik -> jki)
    }
}

# nmap --
# 
# General purpose mapping function for ND lists
# If "continue" or "break" are used, it will return an error.
#
# Syntax:
# nmap $nd $varName $ndlist ... $body; # lmap style, returns value.
# 
# Arguments:
# nd            Number of dimensions (e.g. 1D, 2D, etc.)
# varName       Variable name to iterate with (lmap style)
# ndlist        ndlist to iterate over (lmap style)
# body          Body to evaluate at every iteration

proc ::ndlist::nmap {nd args} {
    # Check arity
    if {[llength $args] == 1 || [llength $args] % 2 == 0} {
        return -code error "wrong # args: should be\
                \"nmap nd varName ndlist ?varName ndlist ...? body\""
    }
    # Interpret input
    set ndims [GetNDims $nd]
    set varMap [lrange $args 0 end-1]
    set varNames [dict keys $varMap]
    set ndlists [dict values $varMap]
    set body [lindex $args end]
    # Handle scalar case
    if {$ndims == 0} {
        uplevel 1 [list lassign $ndlists {*}$varNames]
        return [uplevel 1 $body]
    }
    # Expand all ndlists to have the same shape, and then flatten.
    set dims [GetCombinedShape $ndims {*}$ndlists]
    set ndlists [lmap ndlist $ndlists {nexpand $ndlist {*}$dims}]
    set ndlists [lmap ndlist $ndlists {nflatten $ndims $ndlist}]
    # Update varName-ndlist mapping with flattened ndlists.
    set varMap ""
    foreach varName $varNames ndlist $ndlists {
        lappend varMap [list $varName] $ndlist
    }
    # Perform linear mapping in caller, then reshape and return.
    set flatList [uplevel 1 [list lmap {*}$varMap $body]]
    return [nreshape 1D $flatList {*}$dims]
}

# GetCombinedShape --
# 
# Get combined size for combining ndlists (in nmap)
#
# Syntax:
# GetCombinedShape $ndims $ndlist ...
#
# Arguments:
# ndims             Number of dimensions in each ndlist
# ndlist ...        ndlists to get combined dimensions of (for tiling)

proc ::ndlist::GetCombinedShape {ndims args} {
    set cdims [lrepeat $ndims 1]; # Combined dimensions
    foreach ndlist $args {
        set dims [GetShape $ndims $ndlist]
        set cdims [lmap cdim $cdims dim $dims {
            if {$cdim == 1} {
                set cdim $dim
            } elseif {$dim != 1 && $dim != $cdim} {
                return -code error "incompatible dimensions"
            }
            set cdim
        }]
    }
    return $cdims
}

# nop --
#
# Simple math operations on ndlists.
#
# Syntax:
# nop $nd $ndlist $op $arg ...
# nop $nd $ndlist1 .$op $ndlist2
#
# Arguments:
# nd            Number of dimensions (e.g. 1D, 2D, etc.)
# ndlist        ndlist(s) to iterate over
# op            Valid mathop (see tcl::mathop documentation)
# arg ...       Values to perform mathop with 
#
# Matrix examples:
# nop 2D $matrix /; # Performs reciprocal
# nop 2D $matrix -; # Negates values
# nop 2D $matrix !; # Boolean negation
# nop 2D $matrix + 5 1; # Adds 5 and 1 to each matrix element
# nop 2D $matrix ** 2; # Squares entire matrix
# nop 2D $matrix in {1 2 3}; # Returns boolean matrix, if values are in a list
# nop 2D $x .+ $y; # Element-wise addition of x and y

proc ::ndlist::nop {nd ndlist op args} {
    # Interpret input
    set ndims [GetNDims $nd]
    # Element-wise math operation 
    if {[string index $op 0] eq "."} {
        # Check arity
        if {[llength $args] != 1} {
            return -code error "wrong # args: should be\
                    \"nop nd ndlist1 .op ndlist2\""
        }
        # Interpret input
        set op [string range $op 1 end]
        set ndlist1 $ndlist
        set ndlist2 [lindex $args 0]
        # Perform mapping over two ND lists
        return [nmap $ndims value1 $ndlist1 value2 $ndlist2 {
            ::tcl::mathop::$op $value1 $value2
        }]
    }
    # Perform mapping over single ND list
    napply $ndims ::tcl::mathop::$op $ndlist {*}$args
}

# nexpr --
#
# nmap, but with expr.
#
# Syntax:
# nexpr $nd $varName $ndlist <$varName $ndlist ...> $expr
#
# Arguments:
# varName ...   Variable(s) to map with
# ndlist ...    ND list(s) to map over.
# expr          Tcl math expression to evaluate.

proc ::ndlist::nexpr {nd args} {
    # Check arity
    if {[llength $args] == 1 || [llength $args] % 2 == 0} {
        return -code error "wrong # args: should be\
                \"nexpr nd varName ndlist ?varName ndlist ...? expr"
    }
    # Interpret input
    set ndims [GetNDims $nd]
    set varMap [lrange $args 0 end-1]
    set expr [lindex $args end]
    # Call modified nmap
    tailcall nmap $ndims {*}$varMap [list expr $expr]
}
