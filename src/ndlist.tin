# ndlist.tcl
################################################################################
# N-Dimensional List Implementation

# Copyright (C) 2023 Alex Baker, ambaker1@mtu.edu
# All rights reserved. 

# See the file "LICENSE" in the top level directory for information on usage, 
# redistribution, and for a DISCLAIMER OF ALL WARRANTIES.
################################################################################

# Required packages
package require vutil 0.7

# Define namespace
namespace eval ::ndlist {
    # Internal variables
    variable nmap_i; # nmap index array
    array set nmap_i ""
    variable nmap_break; # nmap break passer
    variable filler 0; # Filler for nreplace
    variable temp; # Temporary ndlist object
    
    # N-dimensional list access and mapping
    namespace export ndlist ndobj; # ND list value and object
    namespace export tensor matrix vector scalar; # ndobj
    namespace export nrepeat; # Create ndlist with one value
    namespace export nreshape; # Create ndlist from a vector
    namespace export nstack; # Combine ndlists
    namespace export nswap; # Swap axes
    namespace export nget; # Get values in ndlist
    namespace export nset; # Set values in ndlist
    namespace export nreplace; # Replace values in-place
    namespace export nop; # Math operations over ndlists
    namespace export nexpr; # Expression mapping over ndlists
    namespace export nmap; # Functional map over ndlists
    namespace export i j k; # Index access commands
}

# NDLIST CREATION
################################################################################

# ndlist --
#
# Create an ndlist of specific dimensionality out of the given values.
# Expands ragged nested lists to the maximum dimensions.
#
# Arguments:
# ndtype        Type of ndlist (e.g. 1D, 2D, etc.)
# value         Value to convert to an ndlist
# &             Option to return a temporary ndlist object

proc ::ndlist::ndlist {nd value args} {
    # Interpret output mode
    set mode value
    if {[llength $args] == 1 && [lindex $args end] eq "&"} {
        set mode ndobj
        set args ""
    }
    # Check arity
    if {[llength $args] != 0} {
        return -code error "wrong # args: should be \"ndlist nd value ?&?\""
    }
    # Interpret input
    set ndims [GetNDims $nd]
    set ndlist $value
    # Switch for return mode
    switch $mode {
        value { # Validate ndlist (and expand if needed)
            if {![IsShape $ndlist {*}[GetShape $ndims $ndlist]]} {
                set ndlist [Expand $ndlist {*}[MaxShape $ndims $ndlist]]
            }
            return $ndlist
        }
        ndobj {ndobj new & $ndims $ndlist}
    }
}

# GetNDims --
#
# Get dimensionality from nd string (uses regex pattern).
# Either a single digit or with a "D" after.
# e.g. "0" or "0D", or "3" or "3d"
# Returns error if invalid syntax
#
# Syntax:
# GetNDims $nd
#
# Arguments:
# nd        Number of dimensions (e.g. 1D, 2D, etc.)

proc ::ndlist::GetNDims {nd} {
    if {![IsNDType $nd]} {
        return -code error "invalid ND syntax"
    }
    string trimright $nd {dD}
}

# IsNDType --
#
# Returns whether an input is an ND string
#
# Syntax:
# IsNDType $arg
#
# Arguments:
# arg:          Argument to check

proc ::ndlist::IsNDType {arg} {
    regexp {^(0|[1-9]\d*)[dD]?$} $arg
}

# IsShape --
#
# Verify that the ndlist is of the specified shape
#
# Syntax:
# IsShape $ndlist $n $m ...
#
# Arguments:
# ndlist        ndlist to check
# n m ...       shape of ndlist

proc ::ndlist::IsShape {ndlist args} {
    # Scalar base case
    if {[llength $args] == 0} {
        return 1
    }
    # Interpret input
    set args [lassign $args n]
    # Vector base case
    if {[llength $ndlist] != $n} {
        return 0
    }
    # Recursion
    foreach ndrow $ndlist {
        if {![IsShape $ndrow {*}$args]} {
            return 0
        }
    }
    return 1
}

# GetShape --
#
# Private procedure to get list of dimensions of an ndlist along first index
#
# Syntax:
# GetShape $ndims $ndlist
#
# Arguments:
# ndims         Number of dimensions
# ndlist        ND list to get dimensions from

proc ::ndlist::GetShape {ndims ndlist} {
    # Get list of dimensions (along first index)
    set dims ""
    foreach i [lrepeat $ndims {}] {
        lappend dims [llength $ndlist]
        set ndlist [lindex $ndlist 0]
    }
    return $dims
}

# MaxShape --
#
# Get shape of ndlist given its ndims
# Recursively determines the maximum dimensions.
#
# Syntax:
# MaxShape $ndims $ndlist

# Arguments:
# ndims         Dimensionality
# ndlist        Ragged ndlist

proc ::ndlist::MaxShape {ndims ndlist} {
    # Scalar base case
    if {$ndims == 0} {
        return
    }
    # Vector base case
    if {$ndims == 1} {
        # Vector
        return [llength $ndlist]
    }
    # Matrix base case
    if {$ndims == 2} {
        # Matrix
        set maxdim 0; # maximum number of columns
        foreach ndrow $ndlist {
            if {[llength $ndrow] > $maxdim} {
                set maxdim [llength $ndrow]
            }
        }
        return [list [llength $ndlist] $maxcols]
    }
    # Recursion for higher dimensions
    incr ndims -1
    set maxdims [lrepeat $ndims 0]
    # Get maximum dimensions from sublists
    foreach ndrow $ndlist {
        set maxdims [lmap maxdim $maxdims dim [MaxShape $ndims $ndrow] {
            expr {$dim > $maxdim ? $dim : $maxdim}
        }]
    }
    return [list [llength $ndlist] {*}$maxdims]
}

# Expand --
#
# Expand an ndlist to specified dimension list, so that lset doesn't throw error
# Fills with "$::ndlist::filler" (default 0) which can be modified by user.
#
# Syntax:
# Expand $ndlist $n1 $n2 ...
#
# Arguments:
# ndlist        ND list to expand
# n1 n2 ...     New dimensions

proc ::ndlist::Expand {ndlist n args} {
    variable filler
    # Expand list as needed
    if {[llength $ndlist] < $n} {
        lappend ndlist {*}[lrepeat [expr {$n-[llength $ndlist]}] $filler]
    }
    # Base case
    if {[llength $args] == 0} {
        return $ndlist
    }
    # Recursion for higher-dimension lists
    lmap sublist $ndlist {
        Expand $sublist {*}$args
    }
}

# ndobj --
#
# Object variable class for ndlists
#
# Syntax:
# ndobj new $refName $nd <$value>
#
# Arguments:
# refName       Variable name for garbage collection
# nd            Number of dimensions (e.g. 1D, 2D, etc.)
# value         Value of ndlist

::vutil::type create ndlist ::ndlist::ndobj {
    # Configure constructor and cloned method to configure namespace path
    constructor {refName nd args} {
        namespace path [concat [namespace path] ::ndlist]
        set (ndims) [GetNDims $nd]; # Verifies nd syntax
        next $refName {*}$args
    }
    method <cloned> {args} {
        namespace path [concat [namespace path] ::ndlist]
        next {*}$args
    }
    # SetValue creates an ndlist (this ensures that input is valid)
    method SetValue {value} {
        next [ndlist $(ndims) $value]
    }
    method info {args} {
        set (shape) [my shape]
        next {*}$args
    }
    
    # Modify left assignment to ensure same dimensionality
    method <- {object} {
        if {[IsNDObject $object] && [$object ndims] != $(ndims)} {
            return -code error "incompatible dimensionality"
        }
        next $object
    }
    export <-
    
    # $ndobj ndims <$nd>
    #
    # Query or set the dimensionality.
    # If increasing the dimensionality, it will call "ndlist" to expand.
    #
    # Arguments:
    # nd        Number of dimensions (e.g. 1D, 2D, etc.)  
    
    method ndims {{nd ""}} {
        if {$nd ne ""} {
            set ndims [GetNDims $nd]
            # Expand ndlist as needed
            if {$ndims > $(ndims)} {
                set (value) [ndlist $ndims $(value)]
            }
            set (ndims) $ndims
        }
        return $(ndims)
    }
    
    # $ndobj shape <$axis>
    #
    # Query the shape of the ndobj, for all dimensions or a specified dim.
    #
    # Arguments:
    # axis      Axis to get shape along
    
    method shape {{axis ""}} {
        nshape [self] $axis
    }
    
    # $ndobj size
    #
    # Get total size of array (number of elements)
    
    method size {} {
        nsize [self]
    }
    
    # $ndobj flatten
    #
    # Flatten and return self
    # Note that flattening a scalar will turn it into a 1-element vector
    
    method flatten {} {
        set (value) [nflatten [self]]
        set (ndims) 1
        return [self]
    }

    # $ndobj reshape $shape
    #
    # Reshape and return self
    #
    # Arguments:
    # $shape        New shape (and dimensionality)
    
    method reshape {shape} {
        # Call the nreshape proc, and assign new dimensionality
        set (value) [nreshape [self]]
        set (ndims) [llength $shape]
        return [self]
    }
    
    # $ndobj transpose <$axis1 $axis2>
    #
    # Transpose and return self.
    #
    # Arguments:
    # axis1         Axis to swap with axis 2 (default 0)
    # axis2         Axis to swap with axis 1 (default 1)
    
    method transpose {args} {
        # Check arity
        if {[llength $args] == 1 || [llength $args] > 2} {
            return -code error "wrong # args: should be\
                    \"ndobj transpose ?axis1 axis2?\""
        }
        set (value) [ntranspose [self] {*}$args]
        return [self]
    }
    
    # $ndobj ' <$axis1 $axis2> <&>
    #
    # Get transpose value of ndobj, with option to make temp obj
    # 
    # Arguments:
    # axis1:        Axis to swap with axis 2 (default 0)
    # axis2:        Axis to swap with axis 1 (default 1)
    # &:            Option to return temporary ndobj
    
    method ' {args} {
        ntranspose [self] {*}$args
    }
    export '
    
    # := --
    #
    # Calls nexpr to do ndlist math, ensuring same dimensionality.
    
    method := {expr} {
        my <- [uplevel 1 [list ::ndlist::nexpr $expr &]]
    }
    export :=
    
    # Basic operators, same as for vutil float type (calls nop)
    method += {expr} {
        set (value) [nop [self] + [uplevel 1 [list expr $expr]]]
    }
    method -= {expr} {
        set (value) [nop [self] - [uplevel 1 [list expr $expr]]]
    }
    method *= {expr} {
        set (value) [nop [self] * [uplevel 1 [list expr $expr]]]
    }
    method /= {expr} {
        set (value) [nop [self] / [uplevel 1 [list expr $expr]]]
    }
    export += -= *= /=
    
    # @ --
    #
    # Method to get or set a value (or ranges of values) in an ndlist
    #
    # Syntax:
    # $ndobj @ $i $j $k; # nget, returns value
    # $ndobj @ $i $j $k &; # nget, returns temporary object
    # $ndobj @ $i $j $k --> $refName; # nget, creates new object
    # $ndobj @ $i $j $k = $value; # nset, by value
    # $ndobj @ $i $j $k := $expr; # nset, by expression
    # $ndobj @ $i $j $k *= $expr; # nset, by 
    # $ndobj1 @ $i $j $k <- $ndobj2; # nset, by object (must match dimension)
    
    $X @ 1 2 & = {1 2 3}
    
    nreplace $ndlist 1 2 
    
    nset $ndlist 1 2 = 1
    
    nget $ndlist 1 2 &
    nreplace $ndlist 1 2 = {1 2 3} &
    nreplace $ndlist 1 2 = 
    
    
    
    nset x : 1 += 5
    nset x {1 2} 5 = {} &
    nget x 1 2 3 &
    
    method @ {args} {
        # Check for illegal use of "&" character.
        if {[lindex $args $(ndims)-1] eq "&"} {
            return -code error "wrong # of indices, should be $(ndims)"
        }
        # Regular "nget"
        if {([llength $args] == $(ndims) && [lindex $args $(ndims)-1] ne "&") 
            || ([llength $args] == $(ndims) + 1 && [lindex $args end] eq "&")
        } then {
            # $ndobj @ i j k <&>
            return [::ndlist::nget $(value) {*}$args]
        }
        # Object manipulation
        if {[llength $args] == $(ndims) + 2} {
            set indices [lrange $args 0 end-2]
            set op [lindex $args end-1]; # Assigment operator
            switch $op {
                = { # Value assignment (returns self)
                    set sublist [lindex $args end]
                    ::ndlist::nset (value) {*}$indices $sublist
                    return [self]
                }
                := { # nexpr assigment (returns self)
                    set expr [lindex $args end]
                    set sublist [uplevel 1 [list ::ndlist::nexpr $expr]]
                    ::ndlist::nset (value) {*}$indices $sublist
                    return [self]
                }
                += { # nop addition (returns self)
                    set expr [lindex $args end]
                    set sublist [::ndlist::nop [my @ {*}$indices &] + \
                            [uplevel 1 [list expr $expr]]]
                    ::ndlist::nset (value) {*}$indices $sublist
                    return [self]
                }
                -= { # nop subtraction (returns self)
                    set expr [lindex $args end]
                    set sublist [::ndlist::nop [my @ {*}$indices &] - \
                            [uplevel 1 [list expr $expr]]]
                    ::ndlist::nset (value) {*}$indices $sublist
                    return [self]
                }
                *= { # nop multiplication (returns self)
                    set expr [lindex $args end]
                    set sublist [::ndlist::nop [my @ {*}$indices &] * \
                            [uplevel 1 [list expr $expr]]]
                    ::ndlist::nset (value) {*}$indices $sublist
                    return [self]
                }
                /= { # nop division (returns self)
                    set expr [lindex $args end]
                    set sublist [::ndlist::nop [my @ {*}$indices &] / \
                            [uplevel 1 [list expr $expr]]]
                    ::ndlist::nset (value) {*}$indices $sublist
                    return [self]
                }
                <- { # Object assigment (returns self)
                    set objName [lindex $args end]
                    # Verify that objName is an ndlist
                    if {![::vutil::type isa ndlist $objName]} {
                        return -code error "\"$objName\" is not an ndlist"
                    }
                    # Verify same ND
                    if {[$objName ndims] != $(ndims)} {
                        return -code error "incompatible dimensionality"
                    }
                    # Perform assigment (checks dimensions)
                    ::ndlist::nset (value) {*}$indices [$objName]
                    return [self]
                }
                --> { # Object creation (returns new object)
                    set refName [lindex $args end]
                    upvar 1 $refName refVar
                    # Use "NGet" to also return the new dimensions
                    set results [::ndlist::NGet $(value) {*}$indices]
                    set subdims [lassign $results sublist]
                    set ndims [llength $subdims]
                    return [::vutil::new ndlist $ndims refVar $sublist]
                }
            }
        }
        # Error cases
        switch $(ndims) {
            0 { # Scalar
                return -code error "wrong # args: should be\
                        \"ndobj @ ?= value | <- obj | --> refName?"
            }
            1 { # Vector
                return -code error "wrong # args: should be\
                        \"ndobj @ i ?= value | <- obj | --> refName?"
            }
            2 { # Matrix
                return -code error "wrong # args: should be\
                        \"ndobj @ i j ?= value | <- obj | --> refName?"
            }
            3 { # 3D tensor
                return -code error "wrong # args: should be\
                        \"ndobj @ i j k ?= value | <- obj | --> refName?"
            }
            default { # Higher order tensor
                return -code error "wrong # args: should be \"ndobj @\
                        i1 ... i$(ndims) ?= value | <- obj | --> refName?"
            }
        }
    }
    export @
    
    # $ndobj ' <$axis1 $axis2> <&>
    #
    # Get transpose of ndlist (or swap axes)
    # 
    # Arguments:
    # axis1:        Axis to swap with axis 2 (default 0)
    # axis2:        Axis to swap with axis 1 (default 1)
    # &:            Option to return temporary ndobj
    
    method ' {args} {
        # Trim pointer reference argument
        if {[lindex $args end] eq "&"} {
            set mode ndobj
            set args [lrange $args 0 end-1]
        } else {
            set mode value
        }
        # Switch for arity
        if {[llength $args] == 0} {
            # Default transpose case
            if {$(ndims) <= 1} {
                set result $(value) 
            } else {
                set result [::ndlist::nswap $(value)]
            }
        } elseif {[llength $args] == 2} {
            # Axis swap case
            lassign [lsort -integer $args] axis1 axis2
            if {$axis2 >= $(ndims)} {
                return -code error "axis out of range"
            }
            set result [::ndlist::nswap $(value) $axis1 $axis2]
        } else {
            return -code error "wrong # args: should be\
                    \"ndobj ' ?axis1 axis2? ?&?\""
        }
        # Return either value or temporary ndobj
        switch $mode {
            value {
                return $result
            }
            ndobj {
                return [::ndlist::TempObj $(ndims) $result]
            }
        }
    }
    export '
}; # end "ndlist" type declaration

# IsNDObject --
#
# Shorthand for calling the vutil "type isa ndlist" command. Returns boolean.
#
# Syntax:
# IsNDObject $arg
# 
# Arguments:
# arg:          Argument to check using "type isa ndlist"

proc ::ndlist::IsNDObject {arg} {
    ::vutil::type isa ndlist $arg
}

# NDLIST OBJECT CREATION ALIASES COMMANDS
################################################################################

# tensor --
#
# Shorthand to create a new ndlist of arbitrary dimension
#
# Syntax:
# tensor $refName $nd <$value>
#
# Arguments:
# refName       Variable name for garbage collection
# nd            Number of dimensions (e.g. 1D, 2D, etc.)
# value         Value to initialize with

proc ::ndlist::tensor {refName nd args} {
    tailcall ndlist new $refName $nd {*}$args
}

# matrix --
#
# Shorthand to create a new 2D ndlist.
#
# Syntax:
# matrix $refName <$value>
#
# Arguments:
# refName       Variable name for garbage collection
# value         Value to set matrix to

proc ::ndlist::matrix {refName args} {
    tailcall ndlist new $refName 2D {*}$args
}

# vector --
#
# Shorthand to create a new 1D ndlist.
#
# Syntax:
# vector $refName <$value>
#
# Arguments:
# refName       Variable name for garbage collection
# value         Value to set vector to

proc ::ndlist::vector {refName args} {
    tailcall ndlist new $refName 1D {*}$args
}

# scalar --
#
# Shorthand to create a new 0D ndlist.
#
# Syntax:
# scalar $refName <$value>
#
# Arguments:
# refName       Variable name for garbage collection
# value         Value of scalar

proc ::ndlist::scalar {refName args} {
    tailcall ndlist new $refName 0D {*}$args
}

# NDLIST INITIALIZATION
################################################################################

# nrepeat --
#
# Create an ndlist filled with one value
#
# Syntax:
# nrepeat $value $shape <&>
#
# Arguments:
# value         Value to repeat
# shape         Dimensions of ndlist
# &             Option to return a temporary ndlist object

proc ::ndlist::nrepeat {value shape args} {
    # Check arity
    if {[llength $args] == 0} {
        set mode value
    } elseif {[llength $args] == 1 && [lindex $args 0] eq "&"} {
        set mode ndobj
    } else {
        return -code error "wrong # args: should be \"nrepeat value shape ?&?\""
    }
    # Create ndlist
    set ndlist $value
    foreach n [lreverse $shape] {
        set ndlist [lrepeat $n $ndlist]
    }
    # Return either value or temporary ndobj
    switch $mode {
        value {return $ndlist}
        ndobj {ndobj & [llength $shape] $ndlist}
    }
}

# NDLIST SHAPE QUERY AND MODIFICATION
################################################################################

# nshape --
# 
# Get shape of ndlist
#
# Syntax:
# nshape $ndobj <$axis>
# nshape $nd $ndlist <$axis>
#
# Arguments:
# ndobj             ND object to get dimensions of
# axis              Axis to get dimension along. Blank for all.
# nd                Number of dimensions (e.g. 1D, 2D, etc.)
# ndlist            ND list to get dimensions of

proc ::ndlist::nshape {args} {
    # Handle ndobj input method
    if {[IsNDObject [lindex $args 0]} {
        # nshape $ndobj <$axis>
        set ndobj [lindex $args 0]
        set args [lreplace $args 0 0 [$ndobj ndims] [$ndobj]]
    }
    # Now input args are normalized to the second syntax type.
    # nshape $nd $ndlist <$axis>
    # Check arity
    if {[llength $args] < 2 || [llength $args] > 3} {
        return -code error "wrong # args: should be\
                \"nshape ndobj ?axis?\" or \"nshape nd ndlist ?axis?\""
    }
    # Interpret input and get dimensionality
    lassign $args nd ndlist axis
    set ndims [GetNDims $nd]
    # Switch for output type
    if {$axis == ""} {
        return [GetShape $ndims $ndlist]
    } elseif {$axis >= 0 && $axis < $ndims} {
        # Get single dimension (along first index)
        return [llength [lindex $ndlist {*}[lrepeat $axis 0]]]
    } else {
        return -code error "axis must be between 0 and [expr {$ndims - 1}]"
    }
}

# nsize --
#
# Get the size of an ndlist (number of elements, product of the shape)
#
# Syntax:
# nsize $ndobj
# nsize $nd $ndlist
#
# Arguments:
# ndobj:            ND list object
# nd:               Number of dimensions (e.g. 1D, 2D, etc.)
# ndlist:           ND list to get dimensions of

proc ::ndlist::nsize {args} {
    # Handle ndobj input method
    if {[IsNDObject [lindex $args 0]} {
        # nsize $ndobj
        set ndobj [lindex $args 0]
        set args [lreplace $args 0 0 [$ndobj ndims] [$ndobj]]
    }
    # Now input args are normalized to the second syntax type.
    # nsize $nd $ndlist
    # Check arity
    if {[llength $args] != 2} {
        return -code error "wrong # args: should be\
                \"nsize ndobj\" or \"nsize nd ndlist\""
    }
    # Interpret input and get dimensionality
    lassign $args nd ndlist
    set ndims [GetNDims $nd]
    # Call private "GetSize" procedure
    return [GetSize $ndims $ndlist]
}

# GetSize --
#
# Private procedure to get total size of an ndlist, using GetShape
#
# Syntax:
# GetSize $ndims $ndlist
#
# Arguments:
# ndims         Number of dimensions
# ndlist        ND list to get size of

proc ::ndlist::GetSize {ndims ndlist} {
    # Get shape using nshape
    set shape [GetShape $ndims $ndlist]
    # Compute size (product of shape)
    set size 1
    foreach dim $shape {
        set size [expr {$size * $dim}]
    }
    return $size
}

# nflatten --
#
# Flatten an ndlist to a vector (1D)
#
# Syntax:
# nflatten $ndobj <&>
# nflatten $nd $ndlist <&>
#
# Arguments:
# ndobj         ND object to manipulate
# nd            Number of dimensions (e.g. 1D, 2D, etc.)
# ndlist        ND list to reshape dimensions of
# &             Option to return a temporary ndlist object

proc ::ndlist::nflatten {args} {
    # Handle ndobj input method
    if {[IsNDObject [lindex $args 0]} {
        # nflatten $ndobj <&>
        set ndobj [lindex $args 0]
        set args [lreplace $args 0 0 [$ndobj ndims] [$ndobj]]
    }
    # Now input args are normalized to the second syntax type.
    # nflatten $nd $ndlist <&>
    # Interpret output mode and trim arguments
    if {[llength $args] > 2 && [lindex $args end] eq "&"} {
        set mode ndobj
        set args [lrange $args 0 end-1]
    } else {
        set mode value
    }
    # Check arity
    if {[llength $args] != 2} {
        return -code error "wrong # args: should be\
                \"nflatten ndobj ?&?\" or \"nflatten nd ndlist ?&?\""
    }
    # Interpret input and get dimensionality
    lassign $args nd ndlist
    set ndims [GetNDims $nd]
    # Handle scalar case
    if {$ndims == 0} {
        # Create a one-element list
        set vector [list $ndlist]
    } else {
        # Flatten the ndlist
        set vector $ndlist
        for {set i 1} {$i < $ndims} {incr i} {
            set vector [concat {*}$vector]
        }
    }
    # Validate that flattening was successful
    if {[llength $vector] != [nsize $ndims $ndlist]} {
        return -code error "invalid ndlist"
    }
    # Return either value or temporary ndobj
    switch $mode {
        value {return $vector}
        ndobj {ndlist & 1 $vector}
    }
}

# nreshape --
#
# Reshape a vector to an ndlist, given dimensions.
#
# Syntax:
# nreshape $ndobj $shape <&>
# nreshape $nd $ndlist $shape <&>
#
# Arguments:
# ndobj         ND object to manipulate
# nd            Number of dimensions (e.g. 1D, 2D, etc.)
# ndlist        ND list to reshape dimensions of
# shape         New shape
# &             Option to return a temporary ndlist object

proc ::ndlist::nreshape {args} {
    # Handle ndobj input method
    if {[IsNDObject [lindex $args 0]} {
        # nreshape $ndobj $shape <&>
        set ndobj [lindex $args 0]
        set args [lreplace $args 0 0 [$ndobj ndims] [$ndobj]]
    }
    # Now input args are normalized to the second syntax type.
    # nreshape $nd $ndlist $shape <&>
    # Interpret output mode and trim arguments
    if {[llength $args] > 3 && [lindex $args end] eq "&"} {
        set mode ndobj
        set args [lrange $args 0 end-1]
    } else {
        set mode value
    }
    # Check arity
    if {[llength $args] != 3} {
        return -code error "wrong # args: should be \"nreshape ndobj\
                shape ?&?\" or \"nreshape nd ndlist shape ?&?\""
    }
    # Interpret input
    lassign $args nd ndlist shape
    # Get flattened ndlist
    set vector [nflatten [GetNDims $nd] $ndlist]
    # Switch for target dimensionality
    if {[llength $shape] == 0} {
        # Scalar (same as flatten)
        set newlist $vector
    } elseif {[llength $shape] == 1} {
        # Vector (verify length, and then return vector)
        if {[lindex $shape 0] != [llength $vector]} {
            return -code error "incompatible dimensions"
        }
        set newlist $vector
    } else {
        # Reshape into matrix or higher-dimension tensor
        set newlist [RecReshape $vector {*}$shape] 
    }
    # Return either value or object
    switch $mode {
        value {return $newlist}
        ndobj {ndlist & [llength $shape] $newlist}
    }
}

# RecReshape --
#
# Recursive handler for reshaping an ndlist
#
# Syntax:
# RecReshape $vector $n $m <$arg ...>
#
# Arguments:
# vector        Vector to reshape into a matrix
# n m           Matrix dimensions
# arg ...       Dimensions of each matrix element. Default scalar.

proc ::ndlist::RecReshape {vector n m args} {
    # Get size of each "row"
    set M $m
    foreach arg $args {
        set M [expr {$M * $arg}]
    }
    # Get total size and compare with vector length
    set size [expr {$n*$M}]
    if {[llength $vector] != $size} {
        return -code error "incompatible dimensions"
    }
    # Create matrix
    set i -$M
    set j -1
    set matrix [lmap x [lrepeat $n {}] {
        lrange $vector [incr i $M] [incr j $M]
    }]
    # Base case
    if {[llength $args] == 0} {
        return $matrix
    }
    # Recursion
    lmap row $matrix {
        RecReshape $row $m {*}$args
    }
}

# ntranspose --
#
# Swaps axes (by default just transposes)
# For 0D and 1D, just returns the value.
#
# Syntax:
# ntranspose $ndobj <$axis1 $axis2> <&>
# ntranspose $nd $ndlist <$axis1 $axis2> <&>
#
# Arguments:
# ndobj         ND object to manipulate
# axis1         Axis to swap with axis 2 (default 0)
# axis2         Axis to swap with axis 1 (default 1)
# &             Option to return an ndobj instead of a value.
# nd:           
# ndlist:       ND list to manipulate

proc ::ndlist::ntranspose {args}
    # Handle ndobj input method
    if {[IsNDObject [lindex $args 0]} {
        # ntranspose $ndobj <$axis1 $axis2> <&>
        set ndobj [lindex $args 0]
        set args [lreplace $args 0 0 [$ndobj ndims] [$ndobj]]
    }
    # Now input args are normalized to the second syntax type.
    # ntranspose $nd $ndlist <$axis1 $axis2> <&>
    # Interpret output mode and trim arguments
    if {[llength $args] > 2 && [lindex $args end] eq "&"} {
        set mode ndobj
        set args [lrange $args 0 end-1]
    } else {
        set mode value
    }
    # Check arity
    if {[llength $args] == 2} {
        # ntranspose $nd $ndlist
        lassign $args nd ndlist
        set axis1 0
        set axis2 1
    } elseif {[llength $args] == 4} {
        # ntranspose $nd $ndlist $axis1 $axis2
        lassign [lsort -integer [lassign $args nd ndlist]] axis1 axis2
    } else {
        return -code error "wrong # args: should be \"ntranspose ndobj ?axis1\
                axis2? ?&?\" or \"ntranspose nd ndlist ?axis1 axis2? ?&?\""
    }
    # Get dimensions
    set ndims [GetNDims $nd]
    # Switch for dimensionality (and check axes)
    if {($ndims == 0 || $ndims == 1) && $axis1 == 0 && $axis2 <= 1}  {
        set transpose $ndlist
    } elseif {$axis1 >= 0 && $axis2 < $ndims} {
        set transpose [RecTranspose $ndlist $axis1 $axis2]
    } else {
        return -code error "axes out of range"
    }
    # Return value or object
    switch $mode {
        value {return $transpose}
        ndobj {ndlist & $ndims $transpose}
    }
}

# RecTranspose --
# 
# Recursive handler for ntranspose (after axes are checked)
#
# Arguments:
# ndlist:           ND list to manipulate
# axis1:            Axis to swap with axis 2
# axis2:            Axis to swap with axis 1

proc ::ndlist::RecTranspose {ndlist axis1 axis2} {
    # Check if at axis to swap
    if {$axis1 == 0} {
        # First transpose
        set ndlist [Transpose $ndlist]; # (ijk -> jik)
        # Base case
        if {$axis2 == 1} {
            return $ndlist
        }
        # Recursion (pass axis1 to axis2 position, and axis2 to axis1+1)
        incr axis2 -1
        set ndlist [lmap ndrow $ndlist {
            set ndrow [RecTranspose $ndrow $axis1 $axis2]; # (jik -> jki)
        }]
        # Final transpose
        return [Transpose $ndlist]; # (jki -> kji)
    }
    # Simple recursion to get to first swap axis
    incr axis1 -1
    incr axis2 -1
    lmap ndrow $ndlist {
        RecTranspose $ndrow $axis1 $axis2
    }
}

# Transpose --
# 
# Transposes a matrix
# Adapted from math::linearalgebra::transpose and lsearch example on Tcl wiki
# written by MJ (https://wiki.tcl-lang.org/page/Transposing+a+matrix)
# 
# Arguments:
# matrix:           Matrix to transpose

proc ::ndlist::Transpose {matrix} {
    set n [llength $matrix]
    set m [llength [lindex $matrix 0]]
    if {$n == 1 && $m == 1} {
        return $matrix
    } elseif {$n > $m} {
        set i -1
        lmap x [lindex $matrix 0] {
            lsearch -all -inline -subindices -index [incr i] $matrix *
        }
    } else {
        set i -1
        lmap x [lindex $matrix 0] {
            incr i
            lmap row $matrix {lindex $row $i}
        }
    }
}

# NDLIST COMBINATION/MANIPULATION
################################################################################

# nstack --
#
# Stack ndlists along a dimension
#
# Syntax:
# nstack $ndobj1 $ndobj2 $axis <&>
# nstack $nd $ndlist1 $ndlist2 $axis <&>
#
# Arguments:
# ndobj1 ndobj2:    ND list objects to stack
# nd:               Number of dimensions (e.g. 1D, 2D, etc.)
# ndlist1 ndlist2:  ND list values to stack
# axis:             Axis to stack along
# &:                Option to return temporary ndobj

proc ::ndlist::nstack {args} {
    # Handle ndobj input method
    if {[IsNDObject [lindex $args 0]]} {
        # nstack $ndobj1 $ndobj2 $axis <&>
        # Validate ndlist objects
        set ndobj1 [lindex $args 0]
        set ndobj2 [lindex $args 1]
        if {![IsNDObject $ndobj2]} {
            return -code error "\"$ndobj2\" is not an ndlist object"
        }
        # Check that they have the same dimensions
        set ndims [$ndobj1 ndims]
        if {[$ndobj2 ndims] != $ndims} {
            return -code error "incompatible dimensionality"
        }
        # Modify arguments to match second syntax type
        set args [lreplace $args 0 1 $ndims [$ndobj1] [$ndobj2]]
    }
    # Now input args are normalized to the second syntax type.
    # nstack $nd $ndlist1 $ndlist2 $axis <&>
    # Interpret output mode and trim arguments
    if {[llength $args] > 2 && [lindex $args end] eq "&"} {
        set mode ndobj
        set args [lrange $args 0 end-1]
    } else {
        set mode value
    }
    # Check arity
    if {[llength $args] != 4} {
        return -code error "wrong # args: should be \"nstack ndobj1 ndobj2\
                axis ?&?\" or \"nstack nd ndlist1 ndlist2 axis ?&?\"" 
    }
    # Interpret input
    lassign $args nd ndlist1 ndlist2 axis
    set ndims [GetNDims $nd]
    # Check validity of ndims/axis
    if {![string is integer -strict $axis]} {
        return -code error "axis must be integer"
    }
    if {$axis < 0 || $axis >= $ndims} {
        return -code error "axis out of range"
    }
    # Verify that dimensions agree on all axes except for the stack axis
    set dims1 [GetShape $ndims $ndlist1]
    set dims2 [GetShape $ndims $ndlist2]
    set i 0
    foreach dim1 $dims1 dim2 $dims2 {
        if {$dim1 ne $dim2 && $i != $axis} {
            return -code error "incompatible dimensions along axis $i"
        }
        incr i
    }
    # Perform stack
    set stacked [RecStack $ndlist1 $ndlist2 $axis]
    # Return either value or temporary ndobj
    switch $mode {
        value {return $stacked}
        ndobj {ndlist & $ndims $stacked}
    }
}

# RecStack --
# 
# Recursive handler for nstack (after dimensions were checked)
#
# Arguments:
# ndlist1 ndlist2:      ndlists to stack
# axis:                 Axis to stack along

proc ::ndlist::RecStack {ndlist1 ndlist2 axis} {
    # Base case
    if {$axis == 0} {
        return [concat $ndlist1 $ndlist2]
    }
    # Recursion
    incr axis -1
    lmap ndrow1 $ndlist1 ndrow2 $ndlist2 {
        RecStack $ndrow1 $ndrow2 $axis
    }
}

# NDLIST ACCESS
################################################################################

# nget --
# 
# Get portion of ndlist using ndlist index notation.
# For ndobj's, use the "@" method.
#
# Syntax:
# nget $ndlist $i1 $i2 ... <&>
#
# Arguments:
# ndlist        ND list value
# i1 i2 ...     Separate arguments for index dimensions
# &             Option to return a temporary object

proc ::ndlist::nget {ndlist args} {
    # Interpret input mode
    if {[lindex $args end] eq "&"} {
        set indices [lrange $args 0 end-1]
        set mode ndobj
    } else {
        set indices $args
        set mode value
    }
    # Get number of dimensions
    set ndims [llength $indices]
    # Scalar case
    if {$ndims == 0} {
        switch $mode {
            value {return $ndlist}
            ndobj {return [ndlist new & $ndims $ndlist]}
        }
    }
    # Parse indices
    set dims [GetShape $ndims $ndlist]
    set iArgs [lassign [ParseIndices $indices $dims] iDims iLims]
    # Process limits and dimensions
    set subdims ""
    foreach dim $dims iLim $iLims iDim $iDims {
        if {$iLim >= $dim} {
            return -code error "index out of range"
        }
        if {$iDim > 0} {
            lappend subdims $iDim
        }
    }
    # Perform recursive indexing
    set sublist [RecGet $ndlist {*}$iArgs]
    # Return either value or temporary ndobj
    switch $mode {
        value {return $sublist}
        ndobj {return [ndlist new & [llength $subdims] $sublist]}
    }
}

# RecGet --
#
# Private recursive handler for nget
#
# Syntax:
# RecGet $ndlist $iType $iList ...
# 
# Arguments:
# ndlist                ndlist to get values from
# iType, iList, ...     Index type and corresponding list. See ParseIndex.

proc ::ndlist::RecGet {ndlist iType iList args} {
    # Base case
    if {[llength $args] == 0} {
        return [Get $ndlist $iType $iList]
    }
    # Flatten for "S" case
    if {$iType eq "S"} {
        RecGet [Get $ndlist $iType $iList] {*}$args
    } else {
        lmap ndrow [Get $ndlist $iType $iList] {
            RecGet $ndrow {*}$args
        }
    }
}

# Get --
#
# Base case for RecGet
#
# Syntax:
# Get $list $iType $iList
#
# Arguments:
# list          List to get values from.
# iType         Index type. See ParseIndex.
# iList         Index list corresponding with index type. See ParseIndex

proc ::ndlist::Get {list iType iList} {
    # Switch for index type
    switch $iType {
        A { # All indices
            return $list
        }
        L { # List of indices
            return [lmap i $iList {
                lindex $list $i
            }]
        }
        R { # Range of indices
            lassign $iList i1 i2
            if {$i2 >= $i1} {
                return [lrange $list $i1 $i2]
            } else {
                return [lreverse [lrange $list $i2 $i1]]
            }
        }
        S { # Single index (flatten)
            set i [lindex $iList 0]
            return [lindex $list $i]
        }
    }
}

# ParseIndices --
# 
# Loop through index inputs - returning required information for getting/setting
# 
# Returns a list - iDim then iArgs, where iArgs is a key-value list
# iDims iLims iType iList iType iList ...

proc ::ndlist::ParseIndices {inputs dims} {
    set iDims ""; # dimensions of indexed region
    set iLims ""; # Maximum indices for indexed region
    set iArgs ""; # paired list of index type and index list (meaning varies)
    foreach input $inputs dim $dims {
        lassign [ParseIndex $input $dim] iDim iLim iType iList 
        lappend iDims $iDim
        lappend iLims $iLim
        lappend iArgs $iType $iList
    }
    return [list $iDims $iLims {*}$iArgs]
}

# ParseIndex --
# 
# Used for parsing index input (i.e. list of indices, range 0:10, etc
# Returns list, with first element being the index input type, and the remaining
# arguments being the index integers.

# Returns:
# iDim:     Dimension of indexed range (e.g. number of indices)
# iLim:     Largest index in indexed range
# iType:    Type of index
#   A:      All indices
#   R:      Range of indices
#   L:      List of indices 
#   S:      Single index (flattens array, iDim = 0)
# iList:    Depends on iType. For range, i1 and i2

proc ::ndlist::ParseIndex {input n} {
    # Check length of input
    if {[llength $input] == 1} {
        # Single index, colon, or range notation
        set index [lindex $input 0]
        # Check for colon (special syntax)
        if {[string match *:* $index]} {
            # Colon or range notation
            if {[string length $index] == 1} {
                # Colon notation (all indices)
                set iType A
                set iList ""
                set iDim $n
                set iLim [expr {$n - 1}]
            } else {
                # Range notation (slice)
                set parts [split $index :]
                if {[llength $parts] == 2} {
                    # Simple range
                    lassign $parts i1 i2
                    set i1 [Index2Integer $i1 $n]
                    set i2 [Index2Integer $i2 $n]
                    set iType R
                    set iList [list $i1 $i2]
                    if {$i2 >= $i1} {
                        # Forward range
                        set iDim [expr {$i2 - $i1 + 1}]
                        set iLim $i2
                    } else {
                        # Reverse range
                        set iDim [expr {$i1 - $i2 + 1}]
                        set iLim $i1
                    }
                } elseif {[llength $parts] == 3} {
                    # Skipped range
                    lassign $parts i1 step i2
                    set i1 [Index2Integer $i1 $n]
                    set i2 [Index2Integer $i2 $n]
                    if {![string is integer -strict $step]} {
                        return -code error "invalid range index notation"
                    }
                    # Deal with range case
                    if {$i2 >= $i1} {
                        if {$step == 1} {
                            # Forward range
                            set iType R
                            set iList [list $i1 $i2]
                            set iDim [expr {$i2 - $i1 + 1}]
                            set iLim $i2; # end of range
                        } else {
                            # Forward stepped range (list)
                            set iType L
                            set iList [Range $i1 $i2 $step]
                            set iDim [llength $iList]
                            set iLim [lindex $iList end]; # end of list
                        }
                    } else {
                        if {$step == -1} {
                            # Reverse range
                            set iType R
                            set iList [list $i1 $i2]
                            set iDim [expr {$i1 - $i2 + 1}]
                            set iLim $i1; # start of range
                        } else {
                            # Reverse stepped range (list)
                            set iType L
                            set iList [Range $i1 $i2 $step]
                            set iDim [llength $iList]
                            set iLim [lindex $iList 0]; # start of list
                        }
                    }
                } else {
                    return -code error "invalid range index notation"
                }
            }; # end if just colon or if range notation
        } elseif {[string index $index end] eq "*"} {
            # Single index notation (flatten along this dimension)
            set i [Index2Integer [string range $index 0 end-1] $n]
            set iType S
            set iList $i
            set iDim 0; # flattens
            set iLim $i
        } else {
            # Single index list (do not flatten)
            set i [Index2Integer $index $n]
            set iType L
            set iList $i
            set iDim 1
            set iLim $i
        }; # end parse single index
    } else {
        # List of indices (user entered)
        set iType L
        set iList [lmap index $input {Index2Integer $index $n}]
        set iDim [llength $iList]
        set iLim 0
        foreach i $iList {
            if {$i > $iLim} {
                set iLim $i
            }
        }
    }
    return [list $iDim $iLim $iType $iList]
}

# Index2Integer --
#
# Private function, converts end+-integer index format into integer
# Negative indices get converted, such that -1 is end, -2 is end-1, etc.
#
# Arguments:
# index:        Tcl index format (integer?[+-]integer? or end?[+-]integer?)
# n:            Length of list to index

proc ::ndlist::Index2Integer {index n} {
    # Default case (skip regexp, much faster)
    if {[string is integer -strict $index]} {
        set i $index
    } else {
        # Check if index is valid format
        set match [regexp -inline {^(end|[+-]?[0-9]+)([+-][0-9]+)?$} $index]
        if {[llength $match] == 0} {
            return -code error "bad index \"$index\": must be\
                    integer?\[+-\]integer? or end?\[+-\]integer?"
        }
        # Convert end to n-1 if needed
        set base [lindex $match 1]
        if {$base eq {end}} {
            set base [expr {$n - 1}]
        }
        # Handle offset
        set offset [lindex $match 2]
        if {$offset eq {}} {
            set i $base
        } else {
            set i [expr {$base + $offset}]
        }
    }
    # Handle negative index (from end)
    if {$i < 0} {
        set i [expr {$i % $n}]
    }
    return $i
}

# Range --
#
# Private handler to generate an integer range
#
# Syntax:
# Range $start $stop $step
# 
# Arguments:
# start:    Start of resultant range.
# stop:     End limit of resultant range.
# step:     Step size.

proc ::ndlist::Range {start stop step} {
    # Avoid divide by zero
    if {$step == 0} {
        return ""
    }
    # Get range length
    set n [expr {($stop - $start)/$step + 1}]
    # Basic cases
    if {$n <= 0} {
        return ""
    }
    if {$n == 1} {
        return $start
    }
    # General case (generate list)
    set i [expr {$start - $step}]
    lmap x [lrepeat $n {}] {incr i $step}
}

# NDLIST MODIFICATION
################################################################################

# nset --
# 
# Set portion of ndlist using ndlist index notation.
# Simply calls nreplace to set new value of ndlist.
#
# Syntax:
# nset $varName $i1 $i2 ... $sublist
#
# Arguments:
# varName       Variable where a valid ndlist is stored
# i1 i2 ...     Separate arguments for index dimensions
# sublist       Sublist to set (must agree in dimension or unity)
#               If blank, removes elements (must remove only along one axis)

# Examples:
# > set a {1 2 3 4}
# > nset a 0:1 {foo bar}
# > puts $a
# foo bar 3 4

proc ::ndlist::nset {varName args} {
    upvar 1 $varName ndlist
    # Initialize ndlist if not set yet
    if {![info exists ndlist]} {
        set ndlist ""
    }
    # Verify that the & operator is not used.
    if {[lindex $args end-1] eq "&"} {
        return -code error "cannot use \"&\" operator for nset"
    }
    set ndlist [nreplace $ndlist {*}$args]
    return $ndlist
}

# nreplace --
#
# Replace portion of ndlist - return new list, same dimension. 
# Can also return an ndobject.
#
# Syntax:
# nreplace $ndlist $i1 $i2 ...  $value <&>
# nreplace $ndlist $i1 $i2 ... <- $ndobj <&>
# 
# Arguments:
# ndlist        Valid ndlist
# i1 i2 ...     Separate arguments for index dimensions
# op            Assignment operator 
# 
# &             Option to return an ndobj instead of a value.
#
# sublist       Sublist to replace with (must agree in dimension or unity)
#               If blank, removes elements (must remove only along one axis)

nreplace {1 2 3} : += 5

nreplace [$x] 2 : <- $y

proc ::ndlist::nreplace {ndlist args} {
    # Search for op, throw error if not found
    set idx [lsearch -regexp $args {^([+\-/*]*=|<-)$}]
    if {$idx == -1} {
        return -code error "need assignment operator: =, +=, -=, *=, /=, or <-"
    }
    # Trim input
    # nreplace $ndlist $i ... $op $value <&>
    set indices [lrange $args 0 $idx-1]; # $i ...
    set op [lindex $args $idx]; # $op
    set args [lrange $args $idx+1 end]; # $value <&>
    # Interpret output mode and trim args again
    if {[llength $args] == 2 && [lindex $args end] eq "&"} {
        set mode ndobj
        set args [lrange $args 0 end-1]
    } else {
        set mode value
    }
    # Check arity
    if {[llength $args] != 1} {
        return -code error "wrong # args: should be\
                \"nreplace ndlist i1 i2 ... op value ?&?\"."
    }
    # Get value to replace with
    set value [lindex $args 0]
    # Get sublist from args
    set sublist [lindex $args end]
    # Interpret input mode
    if {[lindex $args end-1] eq "&"} {
        set indices [lrange $args 0 end-2]
        set mode ndobj
    } else {
        set indices [lrange $args 0 end-1]
        set mode value
    }
    # Get number of dimensions
    set ndims [llength $indices]
    # Scalar case
    if {$ndims == 0} {
        switch $mode {
            value {return $sublist}
            ndobj {return [ndlist new & $ndims $sublist]}
        }
    }
    # Parse indices
    set dims [GetShape $ndims $ndlist]
    set iArgs [lassign [ParseIndices $indices $dims] iDims iLims]
    # Switch for replacement type (removal or substitution)
    if {[llength $sublist] == 0} {
        # Removal/deletion    
        # Get axis to delete along
        set axis -1
        set i 0
        foreach {iType iList} $iArgs {
            if {$iType ne "A"} {
                if {$axis != -1} {
                    return -code error "can only delete along one axis"
                }
                set axis $i
            }
            incr i
        }
        # Trivial case (removal of all)
        if {$axis == -1} {
            return ""
        }
        # Get axis information
        set dim [lindex $dims $axis]
        set iDim [lindex $iDims $axis]
        set iLim [lindex $iLims $axis]
        set iType [lindex $iArgs [expr {$axis * 2}]]
        set iList [lindex $iArgs [expr {$axis * 2 + 1}]]
        # Handle "L" case, indices must be sorted and unique.
        if {$iType eq "L"} {
            set iList [lsort -integer -decreasing -unique $iList]
            set iDim [llength $iList]
        } elseif {$iType eq "S"} {
            set iDim 1; # Single removal
        }
        # Get new dimension along removal axis
        set subdim [expr {$dim - $iDim}]
        # Check for null case
        if {$subdim == 0} {
            return ""
        }
        # Get new dimensions
        set subdims [lreplace $dims $axis $axis $subdim]
        # Call recursive removal handler and return with new dimensions
        set ndlist [RecRemove $ndlist $axis $iType $iList]
    } else {
        # Substitution/replacement
        # Expand ndlist if needed based on index limits.
        foreach dim $dims iLim $iLims {
            if {$iLim >= $dim} {
                # Get expanded dimensions and expand ndlist
                set dims [lmap dim $dims iLim $iLims {
                    expr {$iLim >= $dim ? $iLim + 1 : $dim}
                }]
                set ndlist [Expand $ndlist {*}$dims]
                break
            }
        }
        # Process input dimensions
        set subdims ""
        foreach iDim $iDims {
            if {$iDim > 0} {
                lappend subdims $iDim
            }
        }
        # Tile sublist if needed based on index dimensions.
        set sublist [NTile $sublist {*}$subdims]
        # Call recursive replacement handler
        set ndlist [RecReplace $ndlist $sublist {*}$iArgs]
    }
    # Return either value or object
    switch $mode {
        value {return $ndlist}
        ndobj {return [ndlist new & $ndims $ndlist]}
    }
}

# NReplace --
#
# Private implementation of nreplace. Additionally returns new dimensions.
#
# Syntax:
# nreplace $ndlist $i1 $i2 ... $sublist
# 
# Arguments:
# ndlist        Valid ndlist
# i1 i2 ...     Separate arguments for index dimensions
# sublist       Sublist to replace with (must agree in dimension or unity)
#               If blank, removes elements (must remove only along one axis)

proc ::ndlist::NReplace {ndlist args} {
    # Interpret arguments
    set indices [lrange $args 0 end-1]
    set sublist [lindex $args end]
    set ndims [llength $indices]
    # Scalar case
    if {$ndims == 0} {
        return $sublist
    }
    
}

# RecRemove --
#
# Private recursive handler for removing elements from ndlists
#
# Syntax:
# RecRemove $ndlist $axis $iType $iList
#
# Arguments:
# ndlist:       ndlist to modify
# axis:         Axis to remove on
# iType         Index type, "A" not allowed. See ParseIndex.
# iList         Index list. See ParseIndex.

proc ::ndlist::RecRemove {ndlist axis iType iList} {
    # Base case
    if {$axis == 0} {
        return [Remove $ndlist $iType $iList]
    }
    # Recursion case
    incr axis -1
    set ndlist [lmap ndrow $ndlist {
        RecRemove $ndrow $axis $iType $iList
    }]
    return $ndlist
}

# Remove --
#
# Base case for RecRemove
#
# Syntax:
# Remove $list $iType $iList
# 
# Arguments:
# list          List to remove elements from
# iType         Index type, "A" not allowed. See ParseIndex.
# iList         Index list. See ParseIndex.

proc ::ndlist::Remove {list iType iList} {
    # Base case
    switch $iType {
        L { # Subset of indices
            foreach i $iList {
                set list [lreplace $list $i $i]
            }
        }
        R { # Range of indices
            lassign $iList i1 i2
            if {$i2 >= $i1} {
                set list [lreplace $list $i1 $i2]
            } else {
                set list [lreplace $list $i2 $i1]
            }
        }
        S { # Single index (same as L for removal)
            set i [lindex $iList 0]
            set list [lreplace $list $i $i]
        }
    }
    return $list
}

# NTile --
#
# Tile an ndlist to compatible dimensions.
# A dimension of an ndlist can be tiled if it has dimension 1
#
# Syntax:
# NTile $ndlist $n1 $n2 ...
#
# Arguments:
# ndlist        ND list to tile
# n1 n2 ...     New dimensions

proc ::ndlist::NTile {ndlist args} {    
    set dims1 $args
    set dims0 [GetShape [llength $dims1] $ndlist]
    foreach dim0 $dims0 dim1 $dims1 {
        if {$dim0 != $dim1} {
            return [RecTile $ndlist $dims0 $dims1]
        }
    }
    return $ndlist
}

# RecTile --
#
# Recursive handler for NTile. 
# Tiles a compatible ndlist (dimensions must match or be unity) 
# For example, 1x1, 1x4, 4x1, and 5x4 are all compatible with 5x4.
#
# Syntax:
# RecTile $ndlist $dims0 $dims1
#
# Arguments:
# ndlist        ND list to tile
# dims0         Old dimensions list
# dims1         New dimensions list

proc ::ndlist::RecTile {ndlist dims0 dims1} {
    # Switch for base cases
    if {[llength $dims0] == 0} {
        return $ndlist
    } elseif {[llength $dims0] == 1} {
        return [Tile $ndlist $dims0 $dims1]
    }
    # Strip dimension from args
    set dims0 [lassign $dims0 n0]
    set dims1 [lassign $dims1 n1]
    if {$n0 != $n1} {
        lrepeat $n1 [RecTile [lindex $ndlist 0] $dims0 $dims1]
    } else {
        lmap ndrow $ndlist {
            RecTile $ndrow $dims0 $dims1
        }
    }
}

# Tile --
#
# Base case for RecTile. Throws error if dimensions are incompatible
#
# Syntax:
# Tile $list $n0 $n1
#
# Arguments:
# list          List to tile
# n0            Length of list
# n1            New length of list

proc ::ndlist::Tile {list n0 n1} {
    if {$n0 == $n1} {
        return $list
    } elseif {$n0 == 1} {
        return [lrepeat $n1 [lindex $list 0]]
    } else {
        return -code error "incompatible dimensions"
    }
}

# RecReplace --
#
# Private recursive handler for nreplace
#
# Syntax:
# RecReplace $ndlist $sublist $iType $iList ...
#
# Arguments:
# ndlist        ndlist to modify (pass by value)
# sublist       ndlist to substitute at specified indices
# iType ...     Index type. See ParseIndex.
# iList ...     Index list. See ParseIndex.

proc ::ndlist::RecReplace {ndlist sublist iType iList args} {
    # Base case
    if {[llength $args] == 0} {
        return [Replace $ndlist $sublist $iType $iList]
    }
    # Get portion of ndlist to perform substitution
    set ndrows [Get $ndlist $iType $iList]
    # Recursively replace elements in sublist
    if {$iType eq "S"} {
        set sublist [RecReplace $ndrows $sublist {*}$args]
    } else {
        set sublist [lmap ndrow $ndrows subrow $sublist {
            RecReplace $ndrow $subrow {*}$args
        }]
    }
    # Finally, replace at this level.
    return [Replace $ndlist $sublist $iType $iList]
}

# Replace --
#
# Base case (list) for RecReplace 
#
# Syntax:
# Replace $list $sublist iType iList
#
# Arguments:
# list          list to modify (pass by value)
# sublist       list of values to substitute at specified indices
# iType         Index type. See ParseIndex.
# iList         Index list. See ParseIndex.

proc ::ndlist::Replace {list sublist iType iList} {
    # Switch for index type
    switch $iType {
        A { # All indices
            set list $sublist
        }
        L { # Subset of indices
            foreach i $iList subrow $sublist {
                lset list $i $subrow
            }
        }
        R { # Range of indices
            lassign $iList i1 i2
            if {$i2 >= $i1} {
                set list [lreplace $list $i1 $i2 {*}$sublist]
            } else {
                set list [lreplace $list $i2 $i1 {*}[lreverse $sublist]]
            }
        }
        S { # Single index (flatten)
            set i [lindex $iList 0]
            lset list $i $sublist
        }
    }
    return $list
}

# NDLIST FUNCTIONAL MAPPING COMMANDS
################################################################################

# nop --
#
# Simple math operations on ndlists.
#
# Syntax:
# nop $ndobj $op $opargs <&>
# nop $nd $ndlist $op $opargs <&>
#
# Arguments:
# ndobj:        ndlist object
# nd:           Number of dimensions (e.g. 1D, 2D, etc.)
# ndlist:       ndlist to iterate over
# op:           Valid mathop
# opargs:       Values to perform mathop with (see tcl::mathop documentation)
# &:            Option to return temporary ndobj

# Matrix examples:
# nop 2D $matrix / {}; # Performs reciprocal
# nop 2D $matrix - {}; # Negates values
# nop 2D $matrix ! {}; # Boolean negation
# nop 2D $matrix + {5 1}; # Adds 5 and 1 to each matrix element
# nop 2D $matrix ** 2; # Squares entire matrix
# nop 2D $matrix in {1 2 3}; # Returns boolean matrix, if values are in a list

proc ::ndlist::nop {args} {
    # Interpret input
    if {[IsNDType [lindex $args 0]} {
        # nop $nd $ndlist $op $values <&>
        if {[llength $args] == 4} {
            set mode value
        } elseif {[llength $args] == 5 && [lindex $args end] eq "&"} {
            set mode ndobj
        } else {
            return -code error "wrong # args: should be\
                    \"nop nd ndlist op opargs ?&?\"" 
        }
        lassign $args nd ndlist op opargs
        set ndims [NormalizeND $nd]
    } else {
        # nop $ndobj $op $values <&>
        if {[llength $args] == 3} {
            set mode value
        } elseif {[llength $args] == 4 && [lindex $args end] eq "&"} {
            set mode ndobj
        } else {
            return -code error "wrong # args: should be\
                    \"nop ndobj op opargs ?&?\"" 
        }
        lassign $args ndobj op opargs
        if {![::vutil::type isa ndlist $ndobj]} {
            return -code error "\"$ndobj\" is not an ndlist object"
        }
        set ndlist [$ndobj]
        set ndims [$ndobj ndims]
    }
    # Adjust for list operators
    if {$op in {in ni}} {
        set opargs [list $opargs]
    }
    # Perform operation
    set result [RecOp $ndims $ndlist $op {*}$opargs]
    # Return either value or temporary ndobj
    switch $mode {
        value {
            return $result
        }
        ndobj {
            return [TempObj $ndims $result]
        }
    }
}

# RecOp --
#
# Recursive handler for nop

proc ::ndlist::RecOp {ndims ndlist op args} {
    # Base case
    if {$ndims == 0} {
        return [::tcl::mathop::$op $ndlist {*}$args]
    }
    # Recursion
    incr ndims -1
    lmap ndrow $ndlist {
        RecOp $ndims $ndrow $op {*}$args
    }
}

# nexpr --
# 
# Create a new ndlist based on element-wise operations (calls nmap)
#
# Syntax:
# nexpr $expr <&>; # @ref style
# nexpr $nd $varName $ndlist ... $expr <&>; # lmap style
# 
# Arguments:
# expr:         Expression to evaluate (using @ to reference ndobjs)
# refName:      Reference variable to tie new ndobj to.
# nd:           Number of dimensions (e.g. 1D, 2D, etc.)
# varName:      Variable name to use in expression
# ndlist:       ndlist to iterate over

proc ::ndlist::nexpr {args} {
    # Switch for @ref body style
    if {[llength $args] < 4} {
        # nexpr $expr <&>
        if {[llength $args] == 0 || [llength $args] == 3 ||
            ([llength $args] == 2 && [lindex $args end] ne "&")
        } then {
            return -code error "wrong # args: should be \"nexpr expr ?&?\""
        }
        set args [lassign $args expr]
        tailcall nmap [list expr $expr] {*}$args
    } 
    # Normal case (in the style of lmap)
    set nd [lindex $args 0]
    # Check arity
    if {[llength $args] % 2} {
        # nexpr $nd $varName $ndlist <$varName $ndlist ...> $expr &
        if {[lindex $args end] eq "&"} {
            set varMap [lrange $args 1 end-2]
            set expr [lindex $args end-1]
            tailcall nmap $nd {*}$varMap [list expr $expr] &
        } else {
            return -code error "wrong # args: should be \"nexpr nd varName\
                    ndlist ?varName ndlist ...? expr ?&?\""
        }
    } else {
        # nexpr $nd $varName $ndlist <$varName $ndlist ...> $expr
        set varMap [lrange $args 1 end-1]
        set expr [lindex $args end]
        tailcall nmap $nd {*}$varMap [list expr $expr]
    }
}

# nmap --
# 
# Loop over ndlists. Returns new ndlist like lmap.
# Calling "continue" will skip elements at the lowest level.
# Calling "break" will exit the entire loop.
# Note that the resulting ndlist may not be a proper ndlist if "continue" or 
# "break" are called.
#
# Syntax:
# nmap $body <"&">; # @ref style
# nmap $nd $varName $ndlist ... $body <"&">; # lmap style
# 
# Arguments:
# body:         Body to evaluate
# refName:      Reference variable to tie new ndobj to.
# nd            Number of dimensions (e.g. 1D, 2D, etc.)
# varName       Variable name to iterate with (foreach-loop style)
# ndlist        ndlist to iterate over (foreach-loop style)

proc ::ndlist::nmap {args} {
    variable nmap_i; # array
    variable nmap_break 0; # variable to pass break with
    # Switch for @ref body style
    if {[llength $args] < 4} {
        # Basic arity check
        if {[llength $args] == 0 || [llength $args] == 3} {
            return -code error "wrong # args: should be \"nmap body ?&?\""
        }
        # Get return mode
        if {[llength $args] == 2} {
            if {[lindex $args end] eq "&"} {
                set mode ndobj
            } else {
                return -code error "wrong # args: should be \"nmap body ?&?\""
            }
        } else {
            set mode value
        }
        # Get nmap body and substitute @ refs with array elements
        set body [lindex $args 0]
        # Get mapping of refVars in body
        set exp {@\w+|@{(\\\{|\\\}|[^\\}{]|\\\\)*}}
        set varMap ""
        set ndims 0
        foreach {match submatch} [regexp -inline -all $exp $body] {
            set refName [join [string range $match 1 end]]
            upvar 1 $refName ndobj
            # Validate that reference is to ndlist object
            if {![info exists ndobj]} {
                return -code error "\"$refName\" does not exist"
            }
            if {![::vutil::type isa ndlist $ndobj]} {
                return -code error "\"$refName\" is not an ndlist object"
            }
            # Update body
            set body [regsub $match $body "\$($ndobj)"]
            # Validate dimensionality (must be same)
            if {$ndims == -1} {
                set ndims [$ndobj ndims]
            } elseif {[$ndobj ndims] != $ndims} {
                return -code error "incompatible dimensionality"
            }
            # Update variable map
            if {![dict exists $varMap ($ndobj)]} {
                dict set varMap ($ndobj) [$ndobj]
            }
        }
        # No ndlist objects detected. Simply evaluate as scalar.
        if {[llength $varMap] == 0} {
            # No ndlist objects found. Simply evaluate as a scalar.
            set result [uplevel 1 $body]
        } else {
            # Call normal nmap
            set result [uplevel 1 ::ndlist::nmap $ndims $varMap [list $body]]
        }
        # Unset reference variables
        upvar 1 "" ""
        foreach key [dict keys $varMap] {
            unset $key
        }
        # Return value or assign to object
        switch $mode {
            value {
                return $result
            }
            ndobj {
                return [TempObj $ndims $result]
            }
        }
    }
    
    # Normal case (in the style of lmap)
    # Check arity and get return mode
    if {[llength $args] % 2} {
        # nmap $nd $varName $ndlist <$varName $ndlist ...> $body &
        if {[lindex $args end] eq "&"} {
            set mode ndobj
            set args [lrange $args 0 end-1]
        } else {
            return -code error "wrong # args: should be \"nmap nd varName\
                    ndlist ?varName ndlist ...? body ?&?\""
        }
    } else {
        set mode value
    }
    
    # Save old indices and initialize new
    set old_i [array get nmap_i]
    array unset nmap_i
    try { # Try to perform map, and regardless, restore old indices
        if {[llength $args] == 4} {
            # Loop over a single ndlist (simpler case)
            lassign $args nd varName ndlist body
            set ndims [NormalizeND $nd]
            # Create link variable for SingleMap
            upvar 1 $varName x
            # Scalar case
            if {$ndims == 0} {
                set x $ndlist
                set result [uplevel 1 $body]
            } else {
                set result [SingleMap $ndims $ndlist $body]
            }
        } else {
            # Loop over multiple ndlists
            set nd [lindex $args 0]
            set mapping [dict get [lrange $args 1 end-1]]
            set body [lindex $args end]
            set ndims [GetNDims $nd]
            # Unzip varMap to varNames and ndlists
            set varNames ""
            set ndlists ""
            foreach {varName ndlist} $mapping {
                lappend varNames $varName
                lappend ndlists $ndlist
            }
            # Tile ndlists to combined dimensions
            set cdims [GetCombinedSize $ndims {*}$ndlists]
            set ndlists [lmap ndlist $ndlists {NTile $ndlist {*}$cdims}]
            # Create linkVars for MultiMap
            set i 0
            set linkVars ""
            foreach varName $varNames ndlist $ndlists {
                upvar 1 $varName x$i
                lappend linkVars x$i
                incr i
            }
            # Scalar case
            if {$ndims == 0} {
                lassign $ndlists {*}$linkVars
                set result [uplevel 1 $body]
            } else {
                set result [MultiMap $ndims $linkVars $ndlists $body]
            }
        }
    } finally {
        # Restore previous indices
        array unset nmap_i
        array set nmap_i $old_i
    }
    # Return value or assign to object
    switch $mode {
        value {
            return $result
        }
        ndobj {
            return [TempObj $ndims $result]
        }
    }
}

# GetCombinedSize --
# 
# Get combined size for combining ndlists (in nmap)
#
# Syntax:
# GetCombinedSize $ndims $ndlist ...
#
# Arguments:
# ndims             Number of dimensions in each ndlist
# ndlist ...        ndlists to get combined dimensions of (for tiling)

proc ::ndlist::GetCombinedSize {ndims args} {
    set cdims [lrepeat $ndims 1]; # Combined dimensions
    foreach ndlist $args {
        set dims [GetShape $ndims $ndlist]
        set cdims [lmap cdim $cdims dim $dims {
            if {$cdim == 1} {
                set cdim $dim
            } elseif {$dim != 1 && $dim != $cdim} {
                return -code error "incompatible dimensions"
            }
            set cdim
        }]
    }
    return $cdims
}

# SingleMap --
#
# Private procedure to perform a single loop over ndlist
#
# Syntax:
# SingleMap $ndims $ndlist $body <$axis>
#
# Arguments:
# ndims         Number of dimensions of ndlist
# ndlist        ndlist to loop over
# body          Body to evaluate in caller's caller.
# axis           Recursion variable. Initializes as zero. (depth)

proc ::ndlist::SingleMap {ndims ndlist body {axis 0}} {
    variable nmap_i
    variable nmap_break
    set nmap_i($axis) -1
    if {$ndims == 1} {
        # Base case
        set result [uplevel 1 [list lmap x $ndlist "
            incr nmap_i($axis)
            uplevel 1 [list $body]
        "]]
        # Check for break
        if {$nmap_i($axis) != [llength $ndlist] - 1} {
            set nmap_break 1
        }
        return $result
    } 
    # Recursion case
    tailcall lmap x $ndlist "
        incr nmap_i($axis)
        if {\$nmap_break} {break}
        SingleMap [incr ndims -1] \$x [list $body] [incr axis]
    "
}

# MultiMap --
#
# Used for when there are multiple ndlists.
#
# Syntax:
# MultiMap $ndims $linkVars $ndlists $body <$axis>
# 
# Arguments:
# ndims         Number of dimensions at the current recursion level.
# linkVars      Variables in caller that link to caller's caller.
# ndlists       Lists to iterate over.
# body          Body to evaluate in caller's caller.
# axis          Recursion variable. Initializes as zero. (depth)

proc ::ndlist::MultiMap {ndims linkVars ndlists body {axis 0}} {
    variable nmap_i
    variable nmap_break
    # Create link-value mapping
    set linkMap ""; # mapping of link vars to ndlists
    foreach linkVar $linkVars ndlist $ndlists {
        lappend linkMap $linkVar $ndlist
    }
    # Initialize index
    set nmap_i($axis) -1
    # Base case
    if {$ndims == 1} {
        set result [uplevel 1 [list lmap {*}$linkMap "
            incr nmap_i($axis)
            uplevel 1 [list $body]
        "]]
        # Check for break
        if {$nmap_i($axis) != [llength $ndlist] - 1} {
            set nmap_break 1
        }
        return $result
    }
    # Recursion case
    set linkRef ""; # list of references to link variables
    foreach linkVar $linkVars {
        append linkRef "\$$linkVar "
    }
    tailcall lmap {*}$linkMap "
        incr nmap_i($axis)
        if {\$nmap_break} {break}
        MultiMap [incr ndims -1] [list $linkVars] \[list $linkRef\] \
                [list $body] [incr axis]
    "
}

# i --
#
# Access nmap indices (also works with nexpr)
#
# Syntax:
# i <$axis>
#
# Arguments:
# axis          Dimension to get index from. Default 0

proc ::ndlist::i {{axis 0}} {
    variable nmap_i
    return $nmap_i($axis)
}

# j --
#
# Access second-level nmap index (shorthand for [i 1])

proc ::ndlist::j {} {
    return [i 1]
}

# k --
#
# Access third-level nmap index (shorthand for [i 2])

proc ::ndlist::k {} {
    return [i 2]
}

################################################################################

# Finally, provide the package
package provide ndlist @VERSION@
